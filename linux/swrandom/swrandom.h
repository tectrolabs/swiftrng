/*
 * swrandom.h
 * ver. 2.3
 *
 */

/*
 * SwiftRNG device driver
 *
 * Copyright (C) 2014-2022 TectroLabs, https://tectrolabs.com
 *
 * This is a 'swrandom' kernel module that registers a character device
 * for supplying true random bytes generated by SwiftRNG hardware
 * random number generators.
 *
 * The following devices are supported:
 * SwiftRNG
 * SwiftRNG Pro
 * SwiftRNG Z
 * SwiftRNG LE
 *
 * After the module is successfully loaded by the kernel, the random bytes
 * will be available through /dev/swrandom device.
 *
 * To test, simply plug a SwiftRNG device into one of the available USB ports
 * and run the following command:
 *
 * sudo dd if=/dev/swrandom of=/dev/null bs=100000 count=10
 *
 */
#ifndef SWRANDOM_H_
#define SWRANDOM_H_


#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/proc_fs.h>
#include <linux/init.h>
#include <linux/fs.h>
#include <linux/uaccess.h>
#include <linux/usb.h>
#include <linux/slab.h>
#include <linux/delay.h>

#include <linux/version.h>
#include <linux/moduleparam.h>
#include <linux/errno.h>
#include <linux/err.h>
#include <linux/cdev.h>
#include <linux/device.h>
#include <linux/mutex.h>
#include <linux/kthread.h>
#include <linux/completion.h>


#include <linux/tty.h>
#include <linux/path.h>
#include <linux/namei.h>
#include <linux/termios.h>


#define SUCCESS 0
#define DEVICE_NAME "swrandom"
#define PROC_NAME "info"
#define DRIVER_VERSION "2.3"
#define DRIVER_NAME "SWRNG"


#define WORD_SIZE_BYTES (4)
#define MIN_INPUT_NUM_WORDS (8)
#define OUT_NUM_WORDS (8)
#define NUM_CHUNKS (500)
#define RND_IN_BUFFSIZE (NUM_CHUNKS * MIN_INPUT_NUM_WORDS * WORD_SIZE_BYTES)
#define TRND_OUT_BUFFSIZE (NUM_CHUNKS * OUT_NUM_WORDS * WORD_SIZE_BYTES)
#define USB_BUFFER_SIZE (32000)
#define USB_READ_MAX_RETRY_CNT   (15)
#define USB_READ_TIMEOUT_SECS (1)

#define DEVICE_MODEL_LENGTH   (8)
#define DEVICE_SERIAL_NUM_LENGTH (15)

#define SHA256_PP_METHOD (0)
#define XORSHIFT64_PP_METHOD (1)
#define SHA512_PP_METHOD (2)

#define MAX_ACM_DEVICES_TO_PROBE (5)
#define ACM_DEV_NAME_LENGTH_LIMIT (386)
#define ACM_DEV_NAME_BY_ID_LENGTH_LIMIT (256)

// Max amount of entropy bytes that user can request at a time.
#define MAX_BYTES_USER_CAN_REQUEST (100000)


typedef int (*acm_readdir_t)(void *, const char *, int, loff_t, u64, unsigned);

//
// Function declarations
//
static ssize_t device_read(struct file *file, char __user *buffer, size_t length, loff_t * offset);
static ssize_t proc_read(struct file *file, char __user *buffer, size_t length, loff_t * offset);
static int get_entropy_bytes(void);
static int rcv_rnd_bytes(void);
static int usb_probe(struct usb_interface *interface, const struct usb_device_id *id);
static void usb_disconnect(struct usb_interface *interface);
static void clean_up_usb(void);
static void wait_for_pending_ops(void);
static int chip_read_data(char *buff, int length, int opTimeoutSecs);
static int snd_rcv_usb_data(char *snd, int sizeSnd, char *rcv, int sizeRcv, int opTimeoutSecs);
static int init_char_dev(void);
static void uninit_char_dev(void);
static int create_device(void);
static int create_proc(void);
static void remove_proc(void);
static int set_device_power_profile(void);
static int get_device_version(void);
static int get_device_model(void);
static int get_device_sn(void);
static bool is_post_processing_enabled(void);
static void probe_init(void);
static void log_device_connect_message(void);
static int thread_function(void *data);
static ssize_t thread_device_read(char *buffer, size_t length);
static void clear_receive_buffer(int opTimeoutSecs);

static void sha256_initialize(void);
static void sha256_stampSerialNumber(const void *inputBlock);
static void sha256_initializeSerialNumber(uint32_t initValue);
static int sha256_generateHash(const uint32_t *src, int16_t len, uint32_t *dst);
static void sha256_hashCurrentBlock(void);
static uint32_t sha256_ch(const uint32_t *x, const uint32_t *y, const uint32_t *z);
static uint32_t sha256_maj(const uint32_t *x, const uint32_t *y, const uint32_t *z);
static uint32_t sha256_sum0(const uint32_t *x);
static uint32_t sha256_sum1(const uint32_t *x);
static uint32_t sha256_sigma0(const uint32_t *x);
static uint32_t sha256_sigma1(const uint32_t *x);
static int sha256_selfTest(void);

static void sha512_initialize(void);
static int sha512_generateHash(const uint64_t *src, int16_t len, uint64_t *dst);
static void sha512_hashCurrentBlock(void);
static uint64_t sha512_ch(const uint64_t *x, const uint64_t *y, const uint64_t *z);
static uint64_t sha512_maj(const uint64_t *x, const uint64_t *y, const uint64_t *z);
static uint64_t sha512_sum0(const uint64_t *x);
static uint64_t sha512_sum1(const uint64_t *x);
static uint64_t sha512_sigma0(const uint64_t *x);
static uint64_t sha512_sigma1(const uint64_t *x);
static int sha512_selfTest(void);

static int xorshift64_selfTest(void);
static void xorshift64_postProcess(uint8_t *buffer, int numElements);
static void xorshift64_postProcessWords(uint64_t *buffer, int numElements);
static uint64_t xorshift64_postProcessWord(uint64_t rawWord);
static bool is_xorshift64_enabled(void);

static void test_samples(void);
static void configure_tests(void);

static void rct_initialize(void);
static void rct_restart(void);

static void apt_initialize(void);
static void apt_restart(void);

//
// ACM functions
//
static bool acm_device_probe(void);
static int acm_read(struct file *file, unsigned char *data, int size);
static int acm_full_read(unsigned char *data, int size, int *bytesTransfered);
static int acm_write(struct file *file, const unsigned char *data, int size);
static void acm_close(struct file *file);
static int acm_iterate_dir_callback(struct dir_context *ctx, const char *name, int nameLength, loff_t offset, u64 ino,
      unsigned int dType);
static int acm_readdir(const char* path, acm_readdir_t filler, void* context);
static int acm_filldir_callback(void* data, const char *name, int nameLength, loff_t offset, u64 ino, unsigned int dType);
static void acm_clean_up(void);
static bool acm_set_tty_termios_flags(void);
static bool acm_open_device(void);
static bool acm_lock_device(void);
static struct file *acm_open(const char *path, int flags);

//
// Data section
//

// Mutex for synchronization
static struct mutex dataOpLock;

// Reference to the character device
static struct cdev *cdv = NULL;

// Reference to the character device class
static struct class *dev_class = NULL;

// Reference to the proc parent directory
static struct proc_dir_entry *proc_parent_dir = NULL;

// A flag indication that the proc info can be retrieved
static bool proc_ready_to_read_flag = true;


static struct usb_data {
   struct usb_device *udev;
   __u8 bulk_in_endpointAddr;
   __u8 bulk_out_endpointAddr;
} *usbData;

static struct kthread_data {
   /*
    * Command sent to thread function.
    * Valid commands are:
    * 'r' - requesting entropy bytes
    * 'e' - module is unloading
    */
   char command;
   /*
    * Status returned from the thread function.
    * 0 - for successful operation
    * non zero value - error number
    */
   ssize_t status;

   struct task_struct *drv_thread;
   /*
    * A buffer for storing entropy bytes to be delivered to user space.
    */
   char k_buffer[MAX_BYTES_USER_CAN_REQUEST];
   /*
    * Actual amount of entropy bytes to be delivered which can be less than amount requested from the user space.
    * It must be <= MAX_BYTES_USER_CAN_REQUEST
    */
   size_t k_length;

   struct completion to_thread_event;
   struct completion from_thread_event;

} *threadData;

static struct ctrl_data {
   unsigned char bulk_in_buffer[USB_BUFFER_SIZE];
   unsigned char bulk_out_buffer[1];
   char statusByteHolder[1];
   char deviceVersion[5];
   char deviceModel[9];
   char deviceSN[16];
   long deviceVersionLong;
   bool isPowerProfileSet;
   bool isVersionRetrieved;
   bool isModelRetrieved;
   bool isSNRetrieved;
   char receiveClearBuff[1024];
} *ctrlData;

static struct usb_device_id usb_table[] = {
//Product ID 0x8110 and 0x8111 are reserved and should only be used with TectroLabs Hardware RNG devices
      { USB_DEVICE(0x1fc9, 0x8110)},
      {}
   };

MODULE_DEVICE_TABLE( usb, usb_table);
static struct usb_driver usb_driver = {
      .name = DRIVER_NAME,
      .id_table = usb_table,
      .probe = usb_probe,
      .disconnect = usb_disconnect };

// Major and minor numbers assigned to the char device
static int major = 0;
static int minor = 0;


// Declare device operation handlers
static struct file_operations fops = {
      .owner = THIS_MODULE,
      .read = device_read};

#if LINUX_VERSION_CODE < KERNEL_VERSION(5,05,00)
static struct file_operations proc_fops = {
      .read = proc_read};
#else
static struct proc_ops proc_fops = {
      .proc_read = proc_read};
#endif

// Pointer to the random input buffer
static char *buffRndIn;

// Current index for the buffRndIn buffer
static volatile int curRndInIdx = RND_IN_BUFFSIZE;

// Pointer to the random output buffer
static char *buffTRndOut;

// Current index for the buffTRndOut buffer
static volatile int curTrngOutIdx = TRND_OUT_BUFFSIZE;

// A flag indicating when the entropy source is ready
static volatile bool isEntropySrcRdy = false;

// A flag indicating when there are pending device operations like read or write
static volatile bool isDeviceOpPending = false;

// A flag indicating when there are pending proc operations like read or write
static volatile bool isProcOpPending = false;

// A flag indicating when there are pending USB operations like read or write
static volatile bool isUsbOpPending = false;

// A flag to signal a shutdown event
static volatile bool isShutDown = false;

// The source of one block of data to hash
static uint32_t srcToHash32[MIN_INPUT_NUM_WORDS + 1];

// The source of one block of data to hash
static uint64_t srcToHash64[MIN_INPUT_NUM_WORDS];

// How many statistical test failures allowed per block (16000 random bytes)
static uint8_t numFailuresThreshold = 4;

// Power profile number between 0 and 9 (9 - highest power consumption and also the fastest generation speed)
static short int powerProfile = 9;

// A flag for enabling debug mode
static bool debugMode = false;


// A flag to indicate if the post processing for the raw data should be disabled
static bool disablePostProcessing;

// A flag to indicate if statistical tests for raw data should be disabled.
static bool disableStatisticalTests;

// How many bytes to download per sample.
static int bytesPerSample = TRND_OUT_BUFFSIZE;

// Post processing method used
static char *postProcessingMethod = "";

// Post processing method used
static int postProcessingMethodId = SHA256_PP_METHOD;

// Max number of repetition count test failures encountered per data block
static uint16_t maxRctFailuresPerBlock;

// Max number of adaptive proportion test failures encountered per data block
static uint16_t maxAptFailuresPerBlock;

// Total number of repetition count test failures encountered for current device
static uint64_t totalRctFailuresForCurrentDevice;

// Total number of adaptive proportion test failures encountered for current device
static uint64_t totalAptFailuresForCurrentDevice;

// Last known device status byte
static uint8_t deviceStatusByte = 0;

// Total number of requests handled by device
static uint64_t deviceTotalRequestsHandled = 0;


//.................
// ACM related data
//.................

// Path for finding connected SwiftRNG ACM devices
static char dev_serial_by_id_path[] = "/dev/serial/by-id";

// ACM TTY context
static struct acm_context {
   char dev_name[ACM_DEV_NAME_LENGTH_LIMIT];
   char dev_name_by_id[MAX_ACM_DEVICES_TO_PROBE][ACM_DEV_NAME_BY_ID_LENGTH_LIMIT];
   int devices_found;
   struct path path;
   struct inode *inode;
   dev_t devt;
   struct tty_struct *tty;
   struct ktermios opts;
   struct file *filed;
   bool device_open;
   struct file_lock fl;
   bool device_locked;
} *acmCtxt = NULL;

struct acm_callback_context {
   struct dir_context ctx;
   acm_readdir_t filler;
   void* context;
};


//..........
// Test data
//..........

// Repetition Count Test data
static struct rct_data {
   volatile uint32_t maxRepetitions;
   volatile uint32_t curRepetitions;
   volatile uint8_t lastSample;
   volatile uint8_t statusByte;
   volatile uint8_t signature;
   volatile bool isInitialized;
   volatile uint16_t failureCount;
} rct;

// Adaptive Proportion Test data
static struct apt_data {
   volatile uint16_t windowSize;
   volatile uint16_t cutoffValue;
   volatile uint16_t curRepetitions;
   volatile uint16_t curSamples;
   volatile uint8_t statusByte;
   volatile uint8_t signature;
   volatile bool isInitialized;
   volatile uint8_t firstSample;
   volatile uint16_t cycleFailures;
} apt;

//
// SHA256 data section
//
#define ROTR(sb,w) (((w) >> (sb)) | ((w) << (32-(sb))))

static const uint32_t k[64] = {
      0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
      0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
      0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
      0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
      0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
      0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
      0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
      0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
};

static const uint32_t testSeq1[11] = {
      0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
      0x428a2f98, 0x71374491, 0xb5c0fbcf
};

//
// SHA512 data variable section
//
#define ROTR64(sb,w) (((w) >> (sb)) | ((w) << (64-(sb))))

static const uint64_t sha512_k[80] = {
      0x428a2f98d728ae22, 0x7137449123ef65cd, 0xb5c0fbcfec4d3b2f, 0xe9b5dba58189dbbc,
      0x3956c25bf348b538, 0x59f111f1b605d019, 0x923f82a4af194f9b, 0xab1c5ed5da6d8118,
      0xd807aa98a3030242, 0x12835b0145706fbe, 0x243185be4ee4b28c, 0x550c7dc3d5ffb4e2,
      0x72be5d74f27b896f, 0x80deb1fe3b1696b1, 0x9bdc06a725c71235, 0xc19bf174cf692694,
      0xe49b69c19ef14ad2, 0xefbe4786384f25e3, 0x0fc19dc68b8cd5b5, 0x240ca1cc77ac9c65,
      0x2de92c6f592b0275, 0x4a7484aa6ea6e483, 0x5cb0a9dcbd41fbd4, 0x76f988da831153b5,
      0x983e5152ee66dfab, 0xa831c66d2db43210, 0xb00327c898fb213f, 0xbf597fc7beef0ee4,
      0xc6e00bf33da88fc2, 0xd5a79147930aa725, 0x06ca6351e003826f, 0x142929670a0e6e70,
      0x27b70a8546d22ffc, 0x2e1b21385c26c926, 0x4d2c6dfc5ac42aed, 0x53380d139d95b3df,
      0x650a73548baf63de, 0x766a0abb3c77b2a8, 0x81c2c92e47edaee6, 0x92722c851482353b,
      0xa2bfe8a14cf10364, 0xa81a664bbc423001, 0xc24b8b70d0f89791, 0xc76c51a30654be30,
      0xd192e819d6ef5218, 0xd69906245565a910, 0xf40e35855771202a, 0x106aa07032bbd1b8,
      0x19a4c116b8d2d0c8, 0x1e376c085141ab53, 0x2748774cdf8eeb99, 0x34b0bcb5e19b48a8,
      0x391c0cb3c5c95a63, 0x4ed8aa4ae3418acb, 0x5b9cca4f7763e373, 0x682e6ff3d6b2b8a3,
      0x748f82ee5defb2fc, 0x78a5636f43172f60, 0x84c87814a1f0ab72, 0x8cc702081a6439ec,
      0x90befffa23631e28, 0xa4506cebde82bde9, 0xbef9a3f7b2c67915, 0xc67178f2e372532b,
      0xca273eceea26619c, 0xd186b8c721c0c207, 0xeada7dd6cde0eb1e, 0xf57d4f7fee6ed178,
      0x06f067aa72176fba, 0x0a637dc5a2c898a6, 0x113f9804bef90dae, 0x1b710b35131c471b,
      0x28db77f523047d84, 0x32caab7b40c72493, 0x3c9ebe0a15c9bebc, 0x431d67c49c100d4c,
      0x4cc5d4becb3e42b6, 0x597f299cfc657e2a, 0x5fcb6fab3ad6faec, 0x6c44198c4a475817
};

static const uint64_t sha512_exptHashSeq1[8] = { 0x6cbce8f347e8d1b3, 0xd3517b27fdc4ee1c, 0x71d8406ab54e2335,
      0xf3a39732fa0009d2, 0x2193c41677d18504, 0xe90b4c1138c32e7c, 0xc1aa7500597ba99c, 0xacd525ef2c44e9dc };

static const uint32_t exptHashSeq1[8] = { 0x114c3052, 0x76410592, 0xc024566b, 0xa492b1a2, 0xb0559389, 0xb7c41156,
      0x2ec8d6c3, 0x3dcb02dd };

static const uint8_t maxDataBlockSizeWords = 16;

static struct sha_data {
   uint32_t a, b, c, d, e, f, g, h;
   uint32_t h0, h1, h2, h3, h4, h5, h6, h7;
   uint32_t tmp1, tmp2;
   uint32_t w[64];
   uint32_t blockSerialNumber;
} sd;

struct sha512_data {
   uint64_t a, b, c, d, e, f, g, h;
   uint64_t h0, h1, h2, h3, h4, h5, h6, h7;
   uint64_t tmp1, tmp2;
   uint64_t w[80];
} sd5;


#endif /* SWRANDOM_H_ */
