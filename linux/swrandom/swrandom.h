/*
 * swrandom.h
 * ver. 1.8
 *
 */

/*
 * SwiftRNG device driver - 1.8
 *
 * Copyright (C) 2014-2017 TectroLabs, https://tectrolabs.com
 *
* This is a 'swrandom' kernel module that registers a character device
 * for supplying true random bytes generated by SwiftRNG hardware
 * random number generators.
 *
 * Once the module is successfully built with 'make', it should be loaded
 * into the kernel by running the ins-swrandom.sh script:
 * sudo ./ins-swrandom.sh
 *
 * Use the following command to load the module with a different SwiftRNG
 * power profile number (in this example it will use power profile number 5):
 * sudo ./ins-swrandom.sh powerProfile=5
 *
 * For devices with versions 1.2 and up the post processing can be disabled.
 * To disable post processing use the following command:
 * sudo ./ins-swrandom.sh disablePostProcessing
 *
 * For devices with versions 1.2 and up Marsaglia's Xorshift64 method can be used
 * as a post processing method.
 * To enable Marsaglia's Xorshift64 use the following command:
 * sudo ./ins-swrandom.sh postProcessingMethod=xorshift64
 *
 * To enable SHA-512 post processing use the following command:
 * sudo ./ins-swrandom.sh postProcessingMethod=SHA512
 *
 * After the module is successfully loaded by the kernel, the random bytes
 * will be available for download from the /dev/swrandom device.
 *
 * It can be used to feed the 'rngd' daemon with random data generated
 * by a SwiftRNG device using the following command:
 * sudo rngd -r /dev/swrandom
 *
 * Alternatively you can download the random byte stream into a file using
 * the following command:
 * dd if=/dev/swrandom of=download.bin bs=12000000 count=10
 *
 * The module will automatically detect when a SwiftRNG device is plugged
 * in or unplugged from any USB port.
 *
 * To verify if the 'swrandom' module has successfully detected the SW device,
 * simply check the kernel system logs, you should see a log that should
 * look similar to this:
 *
 *   -----------------------------------------
 *   -- SwiftRNG device connected and ready --
 *   -----------------------------------------
 *
 *
 */
#ifndef SWRANDOM_H_
#define SWRANDOM_H_


#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/init.h>
#include <linux/fs.h>
#include <asm/uaccess.h>
#include <linux/usb.h>
#include <linux/slab.h>
#include <linux/delay.h>

#include <linux/version.h>
#include <linux/moduleparam.h>
#include <linux/fs.h>
#include <linux/errno.h>
#include <linux/err.h>
#include <linux/cdev.h>
#include <linux/device.h>
#include <linux/mutex.h>

#include <asm/uaccess.h>



#define SUCCESS 0
#define DEVICE_NAME "swrandom"
#define DEVICE_VERSION "1.4"

#define WORD_SIZE_BYTES (4)
#define MIN_INPUT_NUM_WORDS (8)
#define OUT_NUM_WORDS (8)
#define NUM_CHUNKS (500)
#define RND_IN_BUFFSIZE (NUM_CHUNKS * MIN_INPUT_NUM_WORDS * WORD_SIZE_BYTES)
#define TRND_OUT_BUFFSIZE (NUM_CHUNKS * OUT_NUM_WORDS * WORD_SIZE_BYTES)
#define USB_BUFFER_SIZE	(32000)
#define USB_READ_MAX_RETRY_CNT	(15)
#define USB_READ_TIMEOUT_SECS	(1)

#define DEVICE_MODEL_LENGTH	(8)
#define DEVICE_SERIAL_NUM_LENGTH	(15)

#define SHA256_PP_METHOD (0)
#define XORSHIFT64_PP_METHOD (1)
#define SHA512_PP_METHOD (2)

//
// Function declarations
//
static int device_open(struct inode *, struct file *);
static int device_release(struct inode *, struct file *);
static ssize_t device_read(struct file *, char *, size_t, loff_t *);
static ssize_t device_write(struct file *, const char *, size_t, loff_t *);
static loff_t device_llseek(struct file *, loff_t, int);
static int get_entropy_bytes(void);
static int rcv_rnd_bytes(void);
static int usb_probe(struct usb_interface *interface, const struct usb_device_id *id);
static void usb_disconnect(struct usb_interface *interface);
static void clean_up_usb(void);
static void wait_for_pending_ops(void);
static int chip_read_data(char *buff, int length, int opTimeoutSecs);
static int snd_rcv_usb_data(char *snd, int sizeSnd, char *rcv, int sizeRcv, int opTimeoutSecs);
static int init_char_dev(void);
static void uninit_char_dev(void);
static int create_device(void);
static int set_device_power_profile(void);
static int get_device_version(void);
static bool is_post_processing_enabled(void);

static void sha256_initialize(void);
static void sha256_stampSerialNumber(void *inputBlock);
static void sha256_initializeSerialNumber(uint32_t initValue);
static int sha256_generateHash(uint32_t *src, int16_t len, uint32_t *dst);
static void sha256_hashCurrentBlock(void);
static uint32_t sha256_ch(uint32_t *x, uint32_t *y, uint32_t *z);
static uint32_t sha256_maj(uint32_t *x, uint32_t *y, uint32_t *z);
static uint32_t sha256_sum0(uint32_t *x);
static uint32_t sha256_sum1(uint32_t *x);
static uint32_t sha256_sigma0(uint32_t *x);
static uint32_t sha256_sigma1(uint32_t *x);
static int sha256_selfTest(void);


static void sha512_initialize(void);
static int sha512_generateHash(uint64_t *src, int16_t len, uint64_t *dst);
static void sha512_hashCurrentBlock(void);
static uint64_t sha512_ch(uint64_t *x, uint64_t *y, uint64_t *z);
static uint64_t sha512_maj(uint64_t *x, uint64_t *y, uint64_t *z);
static uint64_t sha512_sum0(uint64_t *x);
static uint64_t sha512_sum1(uint64_t *x);
static uint64_t sha512_sigma0(uint64_t *x);
static uint64_t sha512_sigma1(uint64_t *x);
static int sha512_selfTest(void);


static int xorshift64_selfTest(void);
static void xorshift64_postProcess(uint8_t *buffer, int numElements);
static void xorshift64_postProcessWords(uint64_t *buffer, int numElements);
static uint64_t xorshift64_postProcessWord(uint64_t rawWord);
static bool is_xorshift64_enabled(void);

static void test_samples(void);
static void configure_tests(void);

static void rct_initialize(void);
static void rct_restart(void);

static void apt_initialize(void);
static void apt_restart(void);


//#define inDebugMode

//
// Data section
//

// Mutex for synchronization
static struct mutex dataOpLock;

// Reference to the character device
struct cdev *cdv = NULL;

// Reference to the character device class
static struct class *dev_class = NULL;


static struct usb_data {
	char					*statusByteHolder;
	char					*deviceVersion;
	long					deviceVersionLong;
	bool					isPowerProfileSet;
	bool					isVersionRetrieved;
	struct usb_device 		*udev;
	struct usb_interface 	*interface;
	unsigned char 			*bulk_out_buffer;
	unsigned char 			*bulk_in_buffer;
	size_t					bulk_in_size;
	__u8					bulk_in_endpointAddr;
	__u8					bulk_out_endpointAddr;
} *usbData;

static struct usb_device_id usb_table[] = {
		//Product ID 0x8110 is reserved and should only be used with TectroLabs Hardware RNG devices
		{ USB_DEVICE(0x1fc9, 0x8110) },
		{ }
};
MODULE_DEVICE_TABLE( usb, usb_table);
static struct usb_driver usb_driver = {
		.name = "SWRNG",
		.id_table = usb_table,
		.probe = usb_probe,
		.disconnect = usb_disconnect };

// Major and minor numbers assigned to the char device
static int major = 0;
static int minor = 0;


// Declare device operation handlers
static struct file_operations fops = {
		.owner = THIS_MODULE,
		.read = device_read,
		.write = device_write,
		.open = device_open,
		.release = device_release,
		.llseek =   device_llseek};

// Pointer to the random input buffer
static char	*buffRndIn;

// Current index for the buffRndIn buffer
static volatile int curRndInIdx = RND_IN_BUFFSIZE;

// Pointer to the random output buffer
static char	*buffTRndOut;

// Current index for the buffTRndOut buffer
static volatile int curTrngOutIdx = TRND_OUT_BUFFSIZE;

// A flag indicating when the entropy source is ready
static volatile bool isEntropySrcRdy = false;

// A flag indicating when there are pending device operations like read or write
static volatile bool isDeviceOpPending = false;

// A flag indicating when there are pending USB operations like read or write
static volatile bool isUsbOpPending = false;

// A flag to signal a shutdown event
static volatile bool isShutDown = false;

// The source of one block of data to hash
static uint32_t srcToHash32[MIN_INPUT_NUM_WORDS + 1];

// The source of one block of data to hash
static uint64_t srcToHash64[MIN_INPUT_NUM_WORDS];

// For real-time statistical tests
static uint8_t numConsecFailThreshold = 5;

// Power profile number between 0 and 9 (9 - highest power consumption and also the fastest generation speed)
static short int powerProfile = 9;

// A flag to indicate if the post processing of raw data should be disabled
static bool disablePostProcessing;

// Post processing method used
static char *postProcessingMethod = "";

// Post processing method used
static int postProcessingMethodId = SHA256_PP_METHOD;


// Repetition Count Test data
static struct rct_data {
	volatile uint32_t maxRepetitions;
	volatile uint32_t curRepetitions;
	volatile uint8_t lastSample;
	volatile uint8_t statusByte;
	volatile uint8_t signature;
	volatile bool isInitialized;
	volatile uint32_t failureWindow;
	volatile uint16_t failureCount;
} rct;

// Adaptive Proportion Test data
static struct apt_data {
	volatile uint16_t windowSize;
	volatile uint16_t cutoffValue;
	volatile uint16_t curRepetitions;
	volatile uint16_t curSamples;
	volatile uint8_t statusByte;
	volatile uint8_t signature;
	volatile bool isInitialized;
	volatile uint8_t firstSample;
	volatile uint16_t cycleFailures;
} apt;

//
// SHA256 data section
//
#define ROTR(sb,w) (((w) >> (sb)) | ((w) << (32-(sb))))

static const uint32_t k[64] = {
	0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
	0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
	0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
	0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
	0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
	0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
	0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
	0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
};

static const uint32_t testSeq1[11] = {
	0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
	0x428a2f98, 0x71374491, 0xb5c0fbcf
};

//
// SHA512 data variable section
//
#define ROTR64(sb,w) (((w) >> (sb)) | ((w) << (64-(sb))))

static const uint64_t sha512_k[80] = {
	0x428a2f98d728ae22, 0x7137449123ef65cd, 0xb5c0fbcfec4d3b2f, 0xe9b5dba58189dbbc,
	0x3956c25bf348b538, 0x59f111f1b605d019, 0x923f82a4af194f9b, 0xab1c5ed5da6d8118,
	0xd807aa98a3030242, 0x12835b0145706fbe, 0x243185be4ee4b28c, 0x550c7dc3d5ffb4e2,
	0x72be5d74f27b896f, 0x80deb1fe3b1696b1, 0x9bdc06a725c71235, 0xc19bf174cf692694,
	0xe49b69c19ef14ad2, 0xefbe4786384f25e3, 0x0fc19dc68b8cd5b5, 0x240ca1cc77ac9c65,
	0x2de92c6f592b0275, 0x4a7484aa6ea6e483, 0x5cb0a9dcbd41fbd4, 0x76f988da831153b5,
	0x983e5152ee66dfab, 0xa831c66d2db43210, 0xb00327c898fb213f, 0xbf597fc7beef0ee4,
	0xc6e00bf33da88fc2, 0xd5a79147930aa725, 0x06ca6351e003826f, 0x142929670a0e6e70,
	0x27b70a8546d22ffc, 0x2e1b21385c26c926, 0x4d2c6dfc5ac42aed, 0x53380d139d95b3df,
	0x650a73548baf63de, 0x766a0abb3c77b2a8, 0x81c2c92e47edaee6, 0x92722c851482353b,
	0xa2bfe8a14cf10364, 0xa81a664bbc423001, 0xc24b8b70d0f89791, 0xc76c51a30654be30,
	0xd192e819d6ef5218, 0xd69906245565a910, 0xf40e35855771202a, 0x106aa07032bbd1b8,
	0x19a4c116b8d2d0c8, 0x1e376c085141ab53, 0x2748774cdf8eeb99, 0x34b0bcb5e19b48a8,
	0x391c0cb3c5c95a63, 0x4ed8aa4ae3418acb, 0x5b9cca4f7763e373, 0x682e6ff3d6b2b8a3,
	0x748f82ee5defb2fc, 0x78a5636f43172f60, 0x84c87814a1f0ab72, 0x8cc702081a6439ec,
	0x90befffa23631e28, 0xa4506cebde82bde9, 0xbef9a3f7b2c67915, 0xc67178f2e372532b,
	0xca273eceea26619c, 0xd186b8c721c0c207, 0xeada7dd6cde0eb1e, 0xf57d4f7fee6ed178,
	0x06f067aa72176fba, 0x0a637dc5a2c898a6, 0x113f9804bef90dae, 0x1b710b35131c471b,
	0x28db77f523047d84, 0x32caab7b40c72493, 0x3c9ebe0a15c9bebc, 0x431d67c49c100d4c,
	0x4cc5d4becb3e42b6, 0x597f299cfc657e2a, 0x5fcb6fab3ad6faec, 0x6c44198c4a475817
};

static const uint64_t sha512_exptHashSeq1[8] = { 0x6cbce8f347e8d1b3, 0xd3517b27fdc4ee1c, 0x71d8406ab54e2335,
		0xf3a39732fa0009d2, 0x2193c41677d18504, 0xe90b4c1138c32e7c, 0xc1aa7500597ba99c, 0xacd525ef2c44e9dc };

static const uint32_t exptHashSeq1[8] = {
	0x114c3052, 0x76410592, 0xc024566b, 0xa492b1a2, 0xb0559389, 0xb7c41156, 0x2ec8d6c3, 0x3dcb02dd
};

static const uint8_t maxDataBlockSizeWords = 16;

static struct sha_data {
	uint32_t a,b,c,d,e,f,g,h;
	uint32_t h0,h1,h2,h3,h4,h5,h6,h7;
	uint32_t tmp1, tmp2;
	uint32_t w[64];
	uint32_t blockSerialNumber;
} sd;

struct sha512_data {
	uint64_t a,b,c,d,e,f,g,h;
	uint64_t h0,h1,h2,h3,h4,h5,h6,h7;
	uint64_t tmp1, tmp2;
	uint64_t w[80];
} sd5;


#endif /* SWRANDOM_H_ */
