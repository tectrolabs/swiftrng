/*
 * swrandom.c
 * ver. 2.2
 *
 */

/*
 * SwiftRNG device driver
 *
 * Copyright (C) 2014-2022 TectroLabs, https://tectrolabs.com
 *
 * This is a 'swrandom' kernel module that registers a character device
 * for supplying true random bytes generated by SwiftRNG hardware
 * random number generators.
 *
 * The following devices are supported:
 * SwiftRNG
 * SwiftRNG Pro
 * SwiftRNG Z
 * SwiftRNG LE
 *
 * After the module is successfully loaded by the kernel, the random bytes
 * will be available through /dev/swrandom device.
 *
 * To test, simply plug a SwiftRNG device into one of the available USB ports
 * and run the following command:
 *
 * sudo dd if=/dev/swrandom of=/dev/null bs=100000 count=10
 *
 */
#include "swrandom.h"

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Andrian Belinski");
MODULE_DESCRIPTION("A module that registers a device for supplying true random bytes generated by Hardware RNG SwiftRNG");
MODULE_VERSION(DRIVER_VERSION);

module_param(powerProfile, short, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);
MODULE_PARM_DESC(powerProfile, "Power profile integer number between 0 and 9 (9 - highest power consumption and also the fastest generation speed)");

module_param(disablePostProcessing, bool, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);
MODULE_PARM_DESC(disablePostProcessing, "A flag to indicate if the post processing of raw data should be disabled.");

module_param(disableStatisticalTests, bool, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);
MODULE_PARM_DESC(disableStatisticalTests, "A flag to indicate if statistical tests for the raw data should be disabled.");

module_param(postProcessingMethod, charp, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);
MODULE_PARM_DESC(postProcessingMethod, "Post processing method to use. Valid options are: SHA256, SHA512 or xorshift64");

module_param(bytesPerSample, int, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);
MODULE_PARM_DESC(bytesPerSample, "How many bytes to download per sample. Valid value must be between 1 and 16000. Providing this parameter may reduce performance.");

module_param(debugMode, bool, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);
MODULE_PARM_DESC(debugMode, "Use this flag to enable debug mode");


/**
 * A function to handle the event when a SwiftRNG device (type USB) is plugged in or connected
 *
 * @param interface - pointer to the usb_interface structure associated with the device
 * @param id -  pointer to the usb_device_id
 * @return 0 - successful operation, otherwise the error code (a negative number)
 *
 */
static int usb_probe(struct usb_interface *interface, const struct usb_device_id *id)
{
   struct usb_host_interface *iface_desc;
   struct usb_endpoint_descriptor *endpoint;
   int i;
   int retval = SUCCESS;

   mutex_lock(&dataOpLock);

   if (isEntropySrcRdy || usbData != NULL) {
      pr_info("%s: usb_probe(): A SwiftRNG device already connected\n", DRIVER_NAME);
      mutex_unlock(&dataOpLock);
      return -EPERM;
   }

   if (isShutDown) {
      pr_info("%s: usb_probe(): Cannot register USB device (%04X:%04X) while module is being removed from the kernel\n", DRIVER_NAME, id->idVendor, id->idProduct);
      mutex_unlock(&dataOpLock);
      return -EPERM;
   }

   iface_desc = interface->cur_altsetting;

   usbData = kzalloc(sizeof(struct usb_data), GFP_KERNEL);
   if (usbData == NULL) {
      pr_err("%s: usb_probe(): Out of memory\n", DRIVER_NAME);
      mutex_unlock(&dataOpLock);
      return -ENOMEM;
   }
   probe_init();

   usbData->udev = usb_get_dev(interface_to_usbdev(interface));

   for (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {
      endpoint = &iface_desc->endpoint[i].desc;

      if (!usbData->bulk_in_endpointAddr && (endpoint->bEndpointAddress & USB_DIR_IN) && ((endpoint->bmAttributes
            & USB_ENDPOINT_XFERTYPE_MASK) == USB_ENDPOINT_XFER_BULK)) {
         usbData->bulk_in_endpointAddr = endpoint->bEndpointAddress;
      }

      if (!usbData->bulk_out_endpointAddr && !(endpoint->bEndpointAddress & USB_DIR_IN) && ((endpoint->bmAttributes
            & USB_ENDPOINT_XFERTYPE_MASK) == USB_ENDPOINT_XFER_BULK)) {
         usbData->bulk_out_endpointAddr = endpoint->bEndpointAddress;
      }
   }

   if (retval == SUCCESS && !(usbData->bulk_in_endpointAddr && usbData->bulk_out_endpointAddr)) {
      pr_err("%s: usb_probe(): Could not find both bulk-in and bulk-out endpoints\n", DRIVER_NAME);
      retval = -EPERM;
   }
   if (retval != SUCCESS) {
      clean_up_usb();
   } else {
      log_device_connect_message();
      if (debugMode) {
         pr_info("Device is using IN bulk address %02X, OUT bulk address %02X\n", usbData->bulk_in_endpointAddr, usbData->bulk_out_endpointAddr);
      }
      isEntropySrcRdy = true;

   }

   mutex_unlock(&dataOpLock);
   return retval;
}

/**
 * A function to handle the event when the SwiftRNG device (type USB) is unplugged or disconnected
 *
 * @param interface - pointer to the usb_interface structure associated with the device
 *
 */
static void usb_disconnect(struct usb_interface *interface)
{
   mutex_lock(&dataOpLock);

   isEntropySrcRdy = false;
   clean_up_usb();
   pr_info("%s: usb_disconnect(): USB device disconnected\n", DRIVER_NAME);
   mutex_unlock(&dataOpLock);
}

/**
 * A function to clean-up the USB allocated resources
 */
static void clean_up_usb(void)
{
   if (usbData != NULL) {
      if (usbData->udev != NULL) {
         usb_put_dev(usbData->udev);
      }
      kfree(usbData);
      usbData = NULL;
   }
}

/**
 * A function called from a thread to read from either USB or ACM device
 *
 * @param buffer - pointer for destination bytes
 * @param length - how many bytes to read
 *
 * @return 0 - successful operation, otherwise the error code (a negative number)
 *
 */
static ssize_t thread_device_read(char *buffer, size_t length)
{
   ssize_t retval = SUCCESS;
   size_t act;
   size_t total;

   if (isShutDown) {
      return -ENODATA;
   }

   if (!isEntropySrcRdy) {
      // No USB device has been probed.
      // Probe for an ACM device.
      if (!acm_device_probe()) {
         // No ACM device has been found
         retval = -ENODATA;
      }
   }

   if (isEntropySrcRdy) {
      total = 0;
      do {
         retval = get_entropy_bytes();
         if (retval == SUCCESS) {
            act = TRND_OUT_BUFFSIZE - curTrngOutIdx;
            if (act > (length - total)) {
               act = (length - total);
            }
            memcpy(buffer + total, buffTRndOut + curTrngOutIdx, act);
            curTrngOutIdx += act;
            total += act;
            retval = total;
         } else {
            if (acmCtxt->device_locked) {
               acm_clean_up();
            }
            break;
         }
      } while (total < length);
      if (debugMode) {
         if (total > length) {
            pr_err("thread_device_read(): Expected %d bytes to read and actually got %d \n", (int)length, (int)total);
         }
      }
   } else {
      retval = -ENODATA;
   }

   return retval;
}

/**
 * A function to handle the event when caller requests a device read operation
 *
 * @param file - pointer to the file structure of the caller
 * @param buffer - pointer to the buffer in the user space
 * @param length - size in bytes for the read operation
 * @param offset
 * @return greater than 0 - number of bytes actually read, otherwise the error code (a negative number)
 *
 */
static ssize_t device_read(struct file *file, char __user *buffer, size_t length, loff_t * offset)
{
   ssize_t retval = SUCCESS;
   unsigned long waitStatus;

   if (isShutDown) {
      return -ENODATA;
   }

   if (length == 0) {
      return 0;
   }

   if (mutex_lock_killable(&dataOpLock) != SUCCESS) {
      if(debugMode) {
         pr_err("%s: device_read(): Could not lock the mutex\n", DRIVER_NAME);
      }
      return -EPERM;
   }

   isDeviceOpPending = true;

   // Create thread command
   threadData->command = 'r';
   threadData->status = -ETIMEDOUT;
   if (length > MAX_BYTES_USER_CAN_REQUEST) {
      // Limit the amount of entropy bytes that can be retrieved at a time
      threadData->k_length = MAX_BYTES_USER_CAN_REQUEST;
   } else {
      threadData->k_length = length;
   }

   if (!completion_done(&threadData->to_thread_event)) {
      complete(&threadData->to_thread_event);
   } else {
      retval = -EBUSY;
      goto return_lable;
   }

   waitStatus = wait_for_completion_timeout(&threadData->from_thread_event, msecs_to_jiffies(5000));
   if (waitStatus == 0) {
      if (debugMode) {
         pr_err("device_read(): thread timeout reached when processing request\n");
      }
      retval = -ETIMEDOUT;
   } else {
      retval = threadData->status;
      if (retval > 0 && retval > MAX_BYTES_USER_CAN_REQUEST) {
         pr_err("%s: device_read(): BUG: invalid return value %d\n", DRIVER_NAME, (int)retval);
         retval = -EFAULT;
      } else if (retval > 0 && retval <= MAX_BYTES_USER_CAN_REQUEST) {
         if (copy_to_user(buffer, threadData->k_buffer, retval)) {
            retval = -EFAULT;
         }
      }
   }

return_lable:
   isDeviceOpPending = false;
   mutex_unlock(&dataOpLock);

   return retval;
}

/**
 * A function to handle the event when caller requests a /proc/swrandom read operation
 *
 * @param file - pointer to the file structure of the caller
 * @param buffer - pointer to the buffer in the user space
 * @param length - size in bytes for the read operation
 * @param offset
 * @return greater than 0 - number of bytes actually read, otherwise the error code (a negative number)
 *
 */
static ssize_t proc_read(struct file *file, char __user *buffer, size_t length, loff_t * offset)
{
   ssize_t len = 0;
   char *msg = NULL;

   if (isShutDown) {
      return -ENODATA;
   }

   if (length == 0) {
      return 0;
   }

   if (mutex_lock_killable(&dataOpLock) != SUCCESS) {
      if(debugMode) {
         pr_err("%s: proc_read(): Could not lock the mutex\n", DRIVER_NAME);
      }
      return -EPERM;
   }
   isProcOpPending = true;

   if (proc_ready_to_read_flag) {
      if (isEntropySrcRdy == false) {
         // No device has been detected
         len = 30;
         copy_to_user(buffer, "No SwiftRNG information found\n", len);
      } else {
         if (ctrlData->isVersionRetrieved == true) {
            // Retrieve device information and statistics
            msg = kasprintf(GFP_KERNEL,
                  "SwiftRNG device model: %s\n"
                  "SwiftRNG device serial number: %s\n"
                  "SwiftRNG device version: %s.%s \n"
                  "SwiftRNG post processing method: %s\n"
                  "SwiftRNG statistical tests: %s\n"
                  "maximum RCT failures per block: %d\n"
                  "maximum APT failures per block: %d\n"
                  "total RCT failures for current device: %lld\n"
                  "total APT failures for current device: %lld\n"
                  ,ctrlData->deviceModel
                  ,ctrlData->deviceSN
                  ,ctrlData->deviceVersion + 1, ctrlData->deviceVersion + 3
                  ,!is_post_processing_enabled() ? "disabled" : is_xorshift64_enabled() ? "Marsaglia's Xorshift64" : postProcessingMethodId == SHA512_PP_METHOD ? "SHA-512" : "SHA-256"
                  ,disableStatisticalTests ? "disabled" : "enabled"
                  ,maxRctFailuresPerBlock
                  ,maxAptFailuresPerBlock
                  ,totalRctFailuresForCurrentDevice
                  ,totalAptFailuresForCurrentDevice);
            if (msg != NULL) {
               len = strlen(msg);
               copy_to_user(buffer, msg, len);
               kfree(msg);
            } else {
               pr_err("proc_read: Could not allocate memory for generating device information\n");
            }
         } else {
            // No device has been initialized
            len = 39;
            copy_to_user(buffer, "The SwiftRNG device wasn't initialized\n", len);
         }
      }
   } else {
      // Device information and statistics already retrieved
      len = 0;
   }

   proc_ready_to_read_flag ^= true;

   isProcOpPending = false;
   mutex_unlock(&dataOpLock);

   return len;
}

/**
 * This is a thread function for handling device commands invoked from the user space.
 * For security reasons command handling logic is executed in a dedicated kernel thread.
 *
 * @param data - a pointer to thread private data
 *
 * @return 0 when shutting down
 */
int thread_function(void *data)
{
   unsigned long waitStatus;
   struct kthread_data *thData = (struct kthread_data *)data;

   while (!isShutDown) {
      waitStatus = wait_for_completion_timeout(&threadData->to_thread_event, msecs_to_jiffies(1000));
      if (waitStatus == 0) {
         continue;
      }

      switch(thData->command) {
      case 'e':
         // Module is unloading, exit the thread.
         return 0;
      case 'r':
         thData->status = thread_device_read(thData->k_buffer, thData->k_length);
         complete(&threadData->from_thread_event);
         break;
      default:
         // Ignore any unexpected commands
         if (debugMode) {
            pr_err("thread_function() unexpected command %c\n", thData->command);
         }
         break;
      }

   }
   return 0;
}

/**
 * Print a notification when SwiftRNG device is initialized
 */
static void log_device_connect_message(void)
{
   pr_info("-------------------------------\n");
   pr_info("-- SwiftRNG device connected --\n");
   pr_info("-------------------------------\n");
}

/**
 * Set device power profile, an integer number between 0 and 9
 * (9 - highest power consumption and also the fastest generation speed)");
 *
 * @return 0 - successful operation, otherwise the error code (a negative number)
 *
 */
static int set_device_power_profile(void)
{
   int retval;

   // Send power profile command to the SW device
   ctrlData->bulk_out_buffer[0] = '0' + powerProfile;
   retval = snd_rcv_usb_data(ctrlData->bulk_out_buffer, 1, ctrlData->statusByteHolder, 0, 10);

   return retval;
}

/**
 * Configure statistical tests
 *
 */
static void configure_tests(void)
{
   switch (ctrlData->deviceVersionLong) {
   case 11:
      numFailuresThreshold = 6;
      break;
   case 10:
      numFailuresThreshold = 9;
      break;
   default:
      numFailuresThreshold = 4;
      break;
   }
   maxRctFailuresPerBlock = 0;
   maxAptFailuresPerBlock = 0;
   totalRctFailuresForCurrentDevice = 0;
   totalAptFailuresForCurrentDevice = 0;

}

/**
 * Check to see if post processing is enabled for the device
 *
 * @return true - post processing is enabled, false otherwise
 *
 */
static bool is_post_processing_enabled(void)
{

   if ((ctrlData->deviceVersionLong >= 12 && disablePostProcessing) || (ctrlData->deviceVersionLong >= 20 && !strcmp("",
         postProcessingMethod))) {
      // Can only disable post processing for devices with version 1.2 and up
      return false;
   }
   return true;
}

/**
 * Check to see if post processing method xosrshift64 is enabled for the device
 *
 * @return true - post processing is enabled, false otherwise
 *
 */
static bool is_xorshift64_enabled(void)
{

   if (ctrlData->deviceVersionLong >= 12 && postProcessingMethodId == XORSHIFT64_PP_METHOD) {
      // Can only use xorshift64 for devices with version 1.2 and up
      return true;
   }
   return false;
}

/**
 * Retrieve device version number.
 *
 * @return 0 - successful operation, otherwise the error code (a negative number)
 *
 */
static int get_device_version(void)
{
   int retval;
   long highVersion;
   long lowVersion;

   // Get device version
   ctrlData->bulk_out_buffer[0] = 'v';
   retval = snd_rcv_usb_data(ctrlData->bulk_out_buffer, 1, ctrlData->deviceVersion, sizeof(ctrlData->deviceVersion) - 1,
         10);

   if (retval == SUCCESS) {
      ctrlData->deviceVersion[4] = '\0';
      ctrlData->deviceVersion[2] = '\0';
      retval = kstrtol(ctrlData->deviceVersion + 1, 10, &highVersion);
      if (retval == SUCCESS) {
         retval = kstrtol(ctrlData->deviceVersion + 3, 10, &lowVersion);
      }
      if (retval == SUCCESS) {
         ctrlData->deviceVersionLong = highVersion * 10 + lowVersion;
      }
   }
   return retval;
}

/**
 * Retrieve device model.
 *
 * @return 0 - successful operation, otherwise the error code (a negative number)
 *
 */
static int get_device_model(void)
{
   int retval;
   int size;

   // Get device model
   size = sizeof(ctrlData->deviceModel) - 1;
   ctrlData->bulk_out_buffer[0] = 'm';
   retval = snd_rcv_usb_data(ctrlData->bulk_out_buffer, 1, ctrlData->deviceModel, size, 10);

   if (retval == SUCCESS) {
      ctrlData->deviceModel[size] = '\0';
   }
   return retval;
}

/**
 * Retrieve device serial number.
 *
 * @return 0 - successful operation, otherwise the error code (a negative number)
 *
 */
static int get_device_sn(void)
{
   int retval;
   int size;

   // Get device serial number
   size = sizeof(ctrlData->deviceSN) - 1;
   ctrlData->bulk_out_buffer[0] = 's';
   retval = snd_rcv_usb_data(ctrlData->bulk_out_buffer, 1, ctrlData->deviceSN, size, 10);

   if (retval == SUCCESS) {
      ctrlData->deviceSN[size] = '\0';
   }
   return retval;
}

/**
 * A function to request new entropy bytes when running out of entropy in the local buffer
 *
 * @return 0 - successful operation, otherwise the error code (a negative number)
 *
 */
static int get_entropy_bytes(void)
{
   int status;
   if (curTrngOutIdx >= TRND_OUT_BUFFSIZE) {
      status = rcv_rnd_bytes();
   } else {
      status = SUCCESS;
   }
   return status;
}

/**
 * A function to fill the buffer with new entropy bytes
 *
 * @return 0 - successful operation, otherwise the error code (a negative number)
 *
 */
static int rcv_rnd_bytes(void)
{
   int retval;
   uint16_t byteCnt;
   int i, j;
   uint32_t *dst32, *src32;
   uint64_t *dst64, *src64;

   if (!isEntropySrcRdy || isShutDown) {
      return -EPERM;
   }

   isUsbOpPending = true;
   retval = SUCCESS;

   if (ctrlData->isPowerProfileSet == false) {
      // Clear the receive buffer before initializing the device
      clear_receive_buffer(USB_READ_TIMEOUT_SECS);
      retval = set_device_power_profile();
      if (retval == SUCCESS) {
         ctrlData->isPowerProfileSet = true;
         pr_info("SwiftRNG device power profile: %d \n", powerProfile);
      } else {
         retval = -EPERM;
      }
   }

   if (ctrlData->isModelRetrieved == false) {
      retval = get_device_model();
      if (retval == SUCCESS) {
         ctrlData->isModelRetrieved = true;
         pr_info("SwiftRNG device model: %s\n", ctrlData->deviceModel);
      } else {
         retval = -EPERM;
      }
   }

   if (ctrlData->isSNRetrieved == false) {
      retval = get_device_sn();
      if (retval == SUCCESS) {
         ctrlData->isSNRetrieved = true;
         pr_info("SwiftRNG device serial number: %s\n", ctrlData->deviceSN);
      } else {
         retval = -EPERM;
      }
   }

   if (ctrlData->isVersionRetrieved == false) {
      retval = get_device_version();
      // Initialize RCT and APT statistical tests
      rct_initialize();
      apt_initialize();
      if (retval == SUCCESS) {
         ctrlData->isVersionRetrieved = true;
         pr_info("SwiftRNG device version: %s.%s \n", ctrlData->deviceVersion + 1, ctrlData->deviceVersion + 3);
         if (is_post_processing_enabled() == true) {
            pr_info("SwiftRNG post processing: enabled\n");
            if (is_xorshift64_enabled() == true) {
               pr_info("SwiftRNG post processing method: Marsaglia's Xorshift64\n");
            } else if (postProcessingMethodId == SHA512_PP_METHOD) {
               pr_info("SwiftRNG post processing method: SHA-512\n");
            } else {
               pr_info("SwiftRNG post processing method: SHA-256\n");
            }
         } else {
            pr_info("SwiftRNG post processing: disabled\n");
         }
      } else {
         retval = -EPERM;
      }
      if (disableStatisticalTests) {
         pr_info("SwiftRNG statistical tests: disabled\n");
      } else {
         pr_info("SwiftRNG statistical tests: enabled\n");
      }

      configure_tests();
   }

   if (retval == SUCCESS) {
      byteCnt = RND_IN_BUFFSIZE;

      ctrlData->bulk_out_buffer[0] = 'x';

      retval = snd_rcv_usb_data(ctrlData->bulk_out_buffer, 1, buffRndIn, RND_IN_BUFFSIZE, USB_READ_TIMEOUT_SECS);
      if (retval == SUCCESS) {
         if (!disableStatisticalTests) {
            rct_restart();
            apt_restart();
            test_samples();
         }
         if (is_post_processing_enabled() == true) {
            if (is_xorshift64_enabled() == true) {
               memcpy(buffTRndOut, buffRndIn, TRND_OUT_BUFFSIZE);
               xorshift64_postProcess((uint8_t *) buffTRndOut, TRND_OUT_BUFFSIZE);
            } else if (postProcessingMethodId == SHA512_PP_METHOD) {
               dst64 = (uint64_t *) buffTRndOut;
               src64 = (uint64_t *) buffRndIn;
               for (i = 0; i < RND_IN_BUFFSIZE / (WORD_SIZE_BYTES * 2); i += MIN_INPUT_NUM_WORDS) {
                  for (j = 0; j < MIN_INPUT_NUM_WORDS; j++) {
                     srcToHash64[j] = src64[i + j];
                  }
                  sha512_generateHash(srcToHash64, MIN_INPUT_NUM_WORDS, dst64);
                  dst64 += OUT_NUM_WORDS;
               }
            } else {
               dst32 = (uint32_t *) buffTRndOut;
               src32 = (uint32_t *) buffRndIn;
               for (i = 0; i < RND_IN_BUFFSIZE / WORD_SIZE_BYTES; i += MIN_INPUT_NUM_WORDS) {
                  for (j = 0; j < MIN_INPUT_NUM_WORDS; j++) {
                     srcToHash32[j] = src32[i + j];
                  }
                  sha256_stampSerialNumber(srcToHash32);
                  sha256_generateHash(srcToHash32, MIN_INPUT_NUM_WORDS + 1, dst32);
                  dst32 += OUT_NUM_WORDS;
               }

            }
         } else {
            memcpy(buffTRndOut, buffRndIn, TRND_OUT_BUFFSIZE);
         }
         curTrngOutIdx = TRND_OUT_BUFFSIZE - bytesPerSample;
         if (rct.statusByte != SUCCESS) {
            pr_err("%s: rcv_rnd_bytes(): Repetition Count Test failure\n", DRIVER_NAME);
            retval = -EPERM;
         } else if (apt.statusByte != SUCCESS) {
            pr_err("%s: rcv_rnd_bytes(): Adaptive Proportion Test failure\n", DRIVER_NAME);
            retval = -EPERM;
         }
      }
   }

   isUsbOpPending = false;
   return retval;
}

/**
 * Send command to device and receive response
 *
 * @param snd -  a pointer to the command
 * @param sizeSnd - how many bytes in command
 * @param rcv - a pointer to the data receive buffer
 * @param sizeRcv - how many bytes expected to receive
 * @param opTimeoutSecs - device read time out value in seconds
 *
 * @return 0 - successful operation, otherwise the error code (a negative number)
 *
 */
static int snd_rcv_usb_data(char *snd, int sizeSnd, char *rcv, int sizeRcv, int opTimeoutSecs)
{
   int retry;
   int actualcCnt;
   int retval = SUCCESS;

   for (retry = 0; retry < USB_READ_MAX_RETRY_CNT; retry++) {
      if (isShutDown) {
         return -EPERM;
      }
      if (acmCtxt->device_locked == false) {
         // Send command to the USB device
         retval = usb_bulk_msg(usbData->udev, usb_sndbulkpipe(usbData->udev, usbData->bulk_out_endpointAddr), snd,
               sizeSnd, &actualcCnt, msecs_to_jiffies(100));
      } else {
         // Send command to the ACM device
         actualcCnt = acm_write(acmCtxt->filed, snd, sizeSnd);
         if (actualcCnt > 0) {
            retval = SUCCESS;
         } else {
            retval = -EFAULT;
         }
      }
      if (retval == SUCCESS && actualcCnt == sizeSnd) {
         retval = chip_read_data(rcv, sizeRcv + 1, opTimeoutSecs);
         if (retval == SUCCESS) {
            if (rcv[sizeRcv] != 0) {
               retval = -EFAULT;
               clear_receive_buffer(opTimeoutSecs);
               if (debugMode) {
                  pr_err("SwiftRNG RNG: received device status code %d\n", rcv[sizeRcv]);
               }
            } else {
               break;
            }
         }
      } else {
         clear_receive_buffer(opTimeoutSecs);
         if (debugMode) {
            pr_err("snd_rcv_usb_data(): It was an error during data communication. Cleaning up the receiving queue and continue.\n");
         }
      }
   }
   if (retry >= USB_READ_MAX_RETRY_CNT) {
      retval = -ETIMEDOUT;
   }
   return retval;
}

/**
 * Function for clearing the receive buffer.
  *
 * @param opTimeoutSecs - device read time out value in seconds
 */
static void clear_receive_buffer(int opTimeoutSecs)
{
   while (chip_read_data(ctrlData->receiveClearBuff, sizeof(ctrlData->receiveClearBuff), opTimeoutSecs) == SUCCESS );
}

/**
 * A function to handle device read request
 *
 * @param buff - a pointer to the data receive buffer
 * @param length - how many bytes expected to receive
 * @param opTimeoutSecs - device read time out value in seconds

 * @return 0 - successful operation, otherwise the error code (a negative number)
 *
 */
static int chip_read_data(char *buff, int length, int opTimeoutSecs)
{
   long secsWaited;
   int transferred;
   ktime_t start, end;
   int cnt;
   int i;
   int retval;

   start = ktime_get();

   cnt = 0;
   do {
      if (isShutDown) {
         return -EPERM;
      }
      if (acmCtxt->device_locked == false) {
         // Retrieve data from the USB device
         retval = usb_bulk_msg(usbData->udev, usb_rcvbulkpipe(usbData->udev, usbData->bulk_in_endpointAddr),
               ctrlData->bulk_in_buffer, length, &transferred, msecs_to_jiffies(200));
      } else {
         // Retrieve data from the ACM device
         retval = acm_full_read(ctrlData->bulk_in_buffer, length, &transferred);
      }
      if (debugMode) {
         pr_info("chip_read_data() retval %d transferred %d, length %d\n", retval, transferred, length);
      }
      if (retval) {
         return retval;
      }

      if (transferred > USB_BUFFER_SIZE) {
         pr_err("%s: chip_read_data(): Received unexpected bytes when processing USB device request\n", DRIVER_NAME);
         return -EFAULT;
      }

      end = ktime_get();
      secsWaited = end - start;
      if (transferred > 0) {
         for (i = 0; i < transferred; i++) {
            buff[cnt++] = ctrlData->bulk_in_buffer[i];
         }
      }
   } while (cnt < length && secsWaited < opTimeoutSecs);

   if (cnt != length) {
      if (debugMode) {
         pr_info("timeout received, cnt %d\n", cnt);
      }
      return -ETIMEDOUT;
   }

   return SUCCESS;
}

/**
 * Initialize the character device
 *
 * @return 0 - successful operation, otherwise the error code (a negative number)
 *
 */
static int init_char_dev(void)
{
   int error;
   int devices_to_destroy;
   dev_t dev;

   error = SUCCESS;
   dev = 0;
   devices_to_destroy = 0;

   error = alloc_chrdev_region(&dev, 0, 1, DEVICE_NAME);
   if (error < 0) {
      pr_err("%s: init_char_dev(): alloc_chrdev_region() call failed with error: %d\n", DRIVER_NAME, error);
      return error;
   }
   major = MAJOR(dev);

   dev_class = class_create(THIS_MODULE, DEVICE_NAME);
   if (IS_ERR(dev_class)) {
      error = PTR_ERR(dev_class);
      goto fail;
   }

   cdv = (struct cdev *) kzalloc(sizeof(struct cdev), GFP_KERNEL);
   if (cdv == NULL) {
      error = -ENOMEM;
      goto fail;
   }

   error = create_device();
   if (error) {
      goto fail;
   }

   return error;

fail:
   uninit_char_dev();
   return error;

}

/**
 * Create the device
 *
 * @return 0 - successful operation, otherwise the error code (a negative number)
 */
static int create_device(void)
{
   int error;
   dev_t devno;
   struct device *device;

   error = SUCCESS;
   device = NULL;
   devno = MKDEV(major, minor);
   cdev_init(cdv, &fops);
   cdv->owner = THIS_MODULE;
   error = cdev_add(cdv, devno, 1);
   if (error) {
      pr_err("%s: create_device(): cdev_add() call failed with error: %d\n", DRIVER_NAME, error);
      return error;
   }
   device = device_create(dev_class, NULL, devno, NULL, DEVICE_NAME);
   if (IS_ERR(device)) {
      error = PTR_ERR(device);
      pr_err("%s: create_device(): device_create() failed with error: %d\n", DRIVER_NAME, error);
      return error;
   }

   return error;
}

/**
 * Create the proc
 *
 * @return 0 - successful operation, otherwise the error code (a negative number)
 */
static int create_proc(void)
{
   // Create a directory under /proc
   proc_parent_dir = proc_mkdir(DEVICE_NAME, NULL);
   if (proc_parent_dir == NULL) {
      return -EPERM;
   }

   // Create the proc entry
   proc_create(PROC_NAME, 0444, proc_parent_dir, &proc_fops);
   return SUCCESS;
}

/**
 * Un-initialize the character device
 *
 */
static void uninit_char_dev(void)
{
   if (cdv) {
      device_destroy(dev_class, MKDEV(major, minor));
      cdev_del(cdv);
      kfree(cdv);
   }
   if (dev_class) {
      class_destroy(dev_class);
   }
   unregister_chrdev_region(MKDEV(major, 0), 1);
}

/**
 * Remove proc directory from /proc
 */
static void remove_proc(void)
{
   if (proc_parent_dir != NULL) {
      proc_remove(proc_parent_dir);
      proc_parent_dir = NULL;
   }
}

/**
 * A function to wait a little for any pending operations.
 * Used when unloading the module.
 *
 */
static void wait_for_pending_ops(void)
{
   int cnt;
   for (cnt = 0; cnt < 100 && (isDeviceOpPending == true || isProcOpPending == true || isUsbOpPending == true); cnt++) {
      msleep(500);
   }
}

/**
 * Initialize the SHA256 data
 *
 */
static void sha256_initialize(void)
{
   // Initialize H0, H1, H2, H3, H4, H5, H6 and H7
   sd.h0 = 0x6a09e667;
   sd.h1 = 0xbb67ae85;
   sd.h2 = 0x3c6ef372;
   sd.h3 = 0xa54ff53a;
   sd.h4 = 0x510e527f;
   sd.h5 = 0x9b05688c;
   sd.h6 = 0x1f83d9ab;
   sd.h7 = 0x5be0cd19;
}

/**
 * Initialize the SHA512 data
 *
 */
static void sha512_initialize(void)
{
   int i;
   // Initialize H0, H1, H2, H3, H4, H5, H6 and H7
   sd5.h0 = 0x6a09e667f3bcc908;
   sd5.h1 = 0xbb67ae8584caa73b;
   sd5.h2 = 0x3c6ef372fe94f82b;
   sd5.h3 = 0xa54ff53a5f1d36f1;
   sd5.h4 = 0x510e527fade682d1;
   sd5.h5 = 0x9b05688c2b3e6c1f;
   sd5.h6 = 0x1f83d9abfb41bd6b;
   sd5.h7 = 0x5be0cd19137e2179;

   for (i = 0; i < 15; i++) {
      sd5.w[i] = 0;
   }
}

/**
 * Stamp a new serial number for the input data block into the last word
 *
 * @param inputBlock pointer to the input hashing block
 *
 */
static void sha256_stampSerialNumber(const void *inputBlock)
{
   uint32_t *inw = (uint32_t*) inputBlock;
   inw[MIN_INPUT_NUM_WORDS] = sd.blockSerialNumber++;
}

/**
 * Initialize the serial number for hashing
 *
 * @param initValue - a startup random number for generating serial number for hashing
 *
 */
static void sha256_initializeSerialNumber(uint32_t initValue)
{
   sd.blockSerialNumber = initValue;
}

/**
 * Generate SHA256 value.
 *
 * @param src - pointer to an array of 32 bit words used as hash input
 * @param dst - pointer to an array of 8 X 32 bit words used as hash output
 * @param len - number of 32 bit words available in array pointed by 'src'
 *
 * @return int 0 for successful operation, -1 for invalid parameters
 *
 */
static int sha256_generateHash(const uint32_t *src, int16_t len, uint32_t *dst)
{

   uint16_t blockNum;
   uint8_t ui8;
   int32_t initialMessageSize;
   uint16_t numCompleteDataBlocks;
   uint16_t reminder;
   uint16_t srcOffset;
   uint8_t needAdditionalBlock;
   uint8_t needToAddOneMarker;

   if (len <= 0) {
      return -1;
   }

   sha256_initialize();

   initialMessageSize = len * 8 * 4;
   numCompleteDataBlocks = len / maxDataBlockSizeWords;
   reminder = len % maxDataBlockSizeWords;

   // Process complete blocks
   for (blockNum = 0; blockNum < numCompleteDataBlocks; blockNum++) {
      srcOffset = blockNum * maxDataBlockSizeWords;
      for (ui8 = 0; ui8 < maxDataBlockSizeWords; ui8++) {
         sd.w[ui8] = src[ui8 + srcOffset];
      }
      // Hash the current block
      sha256_hashCurrentBlock();
   }

   srcOffset = numCompleteDataBlocks * maxDataBlockSizeWords;
   needAdditionalBlock = 1;
   needToAddOneMarker = 1;
   if (reminder > 0) {
      // Process the last data block if any
      ui8 = 0;
      for (; ui8 < reminder; ui8++) {
         sd.w[ui8] = src[ui8 + srcOffset];
      }
      // Append '1' to the message
      sd.w[ui8++] = 0x80000000;
      needToAddOneMarker = 0;
      if (ui8 < maxDataBlockSizeWords - 1) {
         for (; ui8 < maxDataBlockSizeWords - 2; ui8++) {
            // Fill with zeros
            sd.w[ui8] = 0x0;
         }
         // add the message size to the current block
         sd.w[ui8++] = 0x0;
         sd.w[ui8] = initialMessageSize;
         sha256_hashCurrentBlock();
         needAdditionalBlock = 0;
      } else {
         // Fill the rest with '0'
         // Will need to create another block
         sd.w[ui8] = 0x0;
         sha256_hashCurrentBlock();
      }
   }

   if (needAdditionalBlock) {
      ui8 = 0;
      if (needToAddOneMarker) {
         sd.w[ui8++] = 0x80000000;
      }
      for (; ui8 < maxDataBlockSizeWords - 2; ui8++) {
         sd.w[ui8] = 0x0;
      }
      sd.w[ui8++] = 0x0;
      sd.w[ui8] = initialMessageSize;
      sha256_hashCurrentBlock();
   }

   // Save the results
   dst[0] = sd.h0;
   dst[1] = sd.h1;
   dst[2] = sd.h2;
   dst[3] = sd.h3;
   dst[4] = sd.h4;
   dst[5] = sd.h5;
   dst[6] = sd.h6;
   dst[7] = sd.h7;

   return 0;
}

/**
 * Hash current block
 *
 */
static void sha256_hashCurrentBlock(void)
{
   uint8_t t;

   // Process elements 16...63
   for (t = 16; t <= 63; t++) {
      sd.w[t] = sha256_sigma1(&sd.w[t - 2]) + sd.w[t - 7] + sha256_sigma0(&sd.w[t - 15]) + sd.w[t - 16];
   }

   // Initialize variables
   sd.a = sd.h0;
   sd.b = sd.h1;
   sd.c = sd.h2;
   sd.d = sd.h3;
   sd.e = sd.h4;
   sd.f = sd.h5;
   sd.g = sd.h6;
   sd.h = sd.h7;

   // Process elements 0...63
   for (t = 0; t <= 63; t++) {
      sd.tmp1 = sd.h + sha256_sum1(&sd.e) + sha256_ch(&sd.e, &sd.f, &sd.g) + k[t] + sd.w[t];
      sd.tmp2 = sha256_sum0(&sd.a) + sha256_maj(&sd.a, &sd.b, &sd.c);
      sd.h = sd.g;
      sd.g = sd.f;
      sd.f = sd.e;
      sd.e = sd.d + sd.tmp1;
      sd.d = sd.c;
      sd.c = sd.b;
      sd.b = sd.a;
      sd.a = sd.tmp1 + sd.tmp2;
   }

   // Calculate the final hash for the block
   sd.h0 += sd.a;
   sd.h1 += sd.b;
   sd.h2 += sd.c;
   sd.h3 += sd.d;
   sd.h4 += sd.e;
   sd.h5 += sd.f;
   sd.h6 += sd.g;
   sd.h7 += sd.h;
}

/**
 * FIPS PUB 180-4 section 4.1.2 formula (4.2)
 *
 * @param x pointer to variable x
 * @param y pointer to variable y
 * @param z pointer to variable z
 * @return Ch value
 *
 */
static uint32_t sha256_ch(const uint32_t *x, const uint32_t *y, const uint32_t *z)
{
   return ((*x) & (*y)) ^ (~(*x) & (*z));
}

/**
 * FIPS PUB 180-4 section 4.1.2 formula (4.3)
 *
 * @param x pointer to variable x
 * @param y pointer to variable y
 * @param z pointer to variable z
 * @return Maj value
 *
 */
static uint32_t sha256_maj(const uint32_t *x, const uint32_t *y, const uint32_t *z)
{
   return ((*x) & (*y)) ^ ((*x) & (*z)) ^ ((*y) & (*z));
}

/**
 * FIPS PUB 180-4 section 4.1.2 formula (4.4)
 *
 * @param x pointer to variable x
 * @return Sum0 value
 *
 */
static uint32_t sha256_sum0(const uint32_t *x)
{
   return ROTR(2, *x) ^ ROTR(13, *x) ^ ROTR(22, *x);
}

/**
 * FIPS PUB 180-4 section 4.1.2 formula (4.5)
 *
 * @param x pointer to variable x
 * @return Sum1 value
 *
 */
static uint32_t sha256_sum1(const uint32_t *x)
{
   return ROTR(6, *x) ^ ROTR(11, *x) ^ ROTR(25, *x);
}

/**
 * FIPS PUB 180-4 section 4.1.2 formula (4.6)
 *
 * @param x pointer to variable x
 * @return sigma0 value
 *
 */
static uint32_t sha256_sigma0(const uint32_t *x)
{
   return ROTR(7, *x) ^ ROTR(18, *x) ^ ((*x) >> 3);
}

/**
 * FIPS PUB 180-4 section 4.1.2 formula (4.7)
 *
 * @param x pointer to variable x
 * @return sigma1 value
 *
 */
static uint32_t sha256_sigma1(const uint32_t *x)
{
   return ROTR(17, *x) ^ ROTR(19, *x) ^ ((*x) >> 10);
}

/**
 * FIPS PUB 180-4 section 4.1.3 formula (4.8)
 *
 * @param x pointer to variable x
 * @param y pointer to variable y
 * @param z pointer to variable z
 * @return ch value
 *
 */
static uint64_t sha512_ch(const uint64_t *x, const uint64_t *y, const uint64_t *z)
{
   return ((*x) & (*y)) ^ (~(*x) & (*z));
}

/**
 * FIPS PUB 180-4 section 4.1.3 formula (4.9)
 *
 * @param x pointer to variable x
 * @param y pointer to variable y
 * @param z pointer to variable z
 * @return maj value
 *
 */
static uint64_t sha512_maj(const uint64_t *x, const uint64_t *y, const uint64_t *z)
{
   return ((*x) & (*y)) ^ ((*x) & (*z)) ^ ((*y) & (*z));
}

/**
 * FIPS PUB 180-4 section 4.1.3 formula (4.10)
 *
 * @param x pointer to variable x
 * @return sum0 value
 *
 */
static uint64_t sha512_sum0(const uint64_t *x)
{
   return ROTR64(28, *x) ^ ROTR64(34, *x) ^ ROTR64(39, *x);
}

/**
 * FIPS PUB 180-4 section 4.1.3 formula (4.11)
 *
 * @param x pointer to variable x
 * @return sum1 value
 *
 */
static uint64_t sha512_sum1(const uint64_t *x)
{
   return ROTR64(14, *x) ^ ROTR64(18, *x) ^ ROTR64(41, *x);
}

/**
 * FIPS PUB 180-4 section 4.1.3 formula (4.12)
 *
 * @param x pointer to variable x
 * @return sigma0 value
 *
 */
static uint64_t sha512_sigma0(const uint64_t *x)
{
   return ROTR64(1, *x) ^ ROTR64(8, *x) ^ ((*x) >> 7);
}

/**
 * FIPS PUB 180-4 section 4.1.3 formula (4.13)
 *
 * @param x pointer to variable x
 * @return sigma1 value
 *
 */
static uint64_t sha512_sigma1(const uint64_t *x)
{
   return ROTR64(19, *x) ^ ROTR64(61, *x) ^ ((*x) >> 6);
}

/**
 * Run the self test for checking the SHA256 algorithm implementation
 *
 * @return 0 for successful operation
 *
 */
static int sha256_selfTest(void)
{
   uint32_t results[8];
   int retVal;

   retVal = sha256_generateHash((uint32_t*) testSeq1, (uint16_t) 11, (uint32_t*) results);
   if (retVal == 0) {
      // Compare the expected with actual results
      retVal = memcmp(results, exptHashSeq1, 8);
   }
   return retVal;
}

/*
 * A function for running the self test for the SHA512 post processing method
 *
 * @return 0 - successful operation, otherwise the error code (a negative number)
 *
 */
static int sha512_selfTest(void)
{
   uint64_t results[8];
   int retVal;
   retVal = sha512_generateHash((uint64_t *) "8765432187654321876543218765432187654321876543218765432187654321",
         (uint16_t) 8, (uint64_t*) results);
   if (retVal == 0) {
      // Compare the expected with actual results
      retVal = memcmp(results, sha512_exptHashSeq1, 8);
   }
   return retVal;
}

/**
 * Generate SHA512 value.
 *
 * @param src - pointer to an array of 64 bit words used as hash input
 * @param dst - pointer to an array of 8 X 64 bit words used as hash output
 * @param len - number of 64 bit words available in array pointed by 'src'
 *
 * @return 0 for successful operation, -1 for invalid parameters
 *
 */
static int sha512_generateHash(const uint64_t *src, int16_t len, uint64_t *dst)
{
   int i;

   if (len <= 0 || len > 14) {
      return -1;
   }

   sha512_initialize();

   for (i = 0; i < len; i++) {
      sd5.w[i] = src[i];
   }
   sd5.w[i] = 0x8000000000000000;
   sd5.w[15] = len * 64;

   sha512_hashCurrentBlock();

   // Save the results
   dst[0] = sd5.h0;
   dst[1] = sd5.h1;
   dst[2] = sd5.h2;
   dst[3] = sd5.h3;
   dst[4] = sd5.h4;
   dst[5] = sd5.h5;
   dst[6] = sd5.h6;
   dst[7] = sd5.h7;

   return 0;
}

/**
 * Hash current block
 *
 */
static void sha512_hashCurrentBlock(void)
{

   uint8_t t;

   // Process elements 16...79
   for (t = 16; t <= 79; t++) {
      sd5.w[t] = sha512_sigma1(&sd5.w[t - 2]) + sd5.w[t - 7] + sha512_sigma0(&sd5.w[t - 15]) + sd5.w[t - 16];
   }

   // Initialize variables
   sd5.a = sd5.h0;
   sd5.b = sd5.h1;
   sd5.c = sd5.h2;
   sd5.d = sd5.h3;
   sd5.e = sd5.h4;
   sd5.f = sd5.h5;
   sd5.g = sd5.h6;
   sd5.h = sd5.h7;

   // Process elements 0...79
   for (t = 0; t <= 79; t++) {
      sd5.tmp1 = sd5.h + sha512_sum1(&sd5.e) + sha512_ch(&sd5.e, &sd5.f, &sd5.g) + sha512_k[t] + sd5.w[t];
      sd5.tmp2 = sha512_sum0(&sd5.a) + sha512_maj(&sd5.a, &sd5.b, &sd5.c);
      sd5.h = sd5.g;
      sd5.g = sd5.f;
      sd5.f = sd5.e;
      sd5.e = sd5.d + sd5.tmp1;
      sd5.d = sd5.c;
      sd5.c = sd5.b;
      sd5.b = sd5.a;
      sd5.a = sd5.tmp1 + sd5.tmp2;
   }

   // Calculate the final hash for the block
   sd5.h0 += sd5.a;
   sd5.h1 += sd5.b;
   sd5.h2 += sd5.c;
   sd5.h3 += sd5.d;
   sd5.h4 += sd5.e;
   sd5.h5 += sd5.f;
   sd5.h6 += sd5.g;
   sd5.h7 += sd5.h;
}

/**
 * Run the self test for checking the xorshift64 algorithm implementation
 *
 * @return 0 for successful operation
 *
 */
static int xorshift64_selfTest(void)
{
   uint64_t rawWord = 0x1212121212121212;
   uint64_t testWord = 0x2322d6d77d8b7b55;
   xorshift64_postProcess((uint8_t*) &rawWord, 8);

   if (rawWord == testWord) {
      return 0;
   } else {
      return -1;
   }
}

/**
 * @param buffer - pointer to data buffer
 * @param numElements - number of elements in the input buffer
 */
static void xorshift64_postProcess(uint8_t *buffer, int numElements)
{
   xorshift64_postProcessWords((uint64_t *) buffer, numElements / 8);
}

/**
 *
 * @param buffer - pointer to data buffer
 * @param numElements - number of elements in the input buffer
 */
static void xorshift64_postProcessWords(uint64_t *buffer, int numElements)
{
   int i;
   for (i = 0; i < numElements; i++) {
      buffer[i] = xorshift64_postProcessWord(buffer[i]);
   }
}

/**
 * Apply Xorshift64 (Marsaglia's PPRNG method) to the raw word
 * @param rawWord - word to post process
 *
 * @retrurn hash value
 */
static uint64_t xorshift64_postProcessWord(uint64_t rawWord)
{
   uint64_t trueWord = rawWord;

   trueWord ^= trueWord >> 12;
   trueWord ^= trueWord << 25;
   trueWord ^= trueWord >> 27;
   return trueWord * (uint64_t) 2685821657736338717;
}

/**
 * A function for testing a block of random bytes using 'repetition count'
 * and 'adaptive proportion' tests
 */
static void test_samples(void)
{
   uint8_t value;
   int i;

   for (i = 0; i < TRND_OUT_BUFFSIZE; i++) {
      value = buffRndIn[i];

      //
      // Run 'repetition count' test
      //
      if (!rct.isInitialized) {
         rct.isInitialized = true;
         rct.lastSample = value;
      } else {
         if (rct.lastSample == value) {
            rct.curRepetitions++;
            if (rct.curRepetitions >= rct.maxRepetitions) {
               rct.curRepetitions = 1;
               totalRctFailuresForCurrentDevice++;
               if (++rct.failureCount > numFailuresThreshold) {
                  if (rct.statusByte == 0) {
                     rct.statusByte = rct.signature;
                  }
               }

               if (rct.failureCount > maxRctFailuresPerBlock) {
                  // Record the maximum failures per block for reporting
                  maxRctFailuresPerBlock = rct.failureCount;
               }

               if (debugMode) {
                  if (rct.failureCount >= 1) {
                     pr_info("rct.failureCount: %d value: %d\n", rct.failureCount, value);
                  }
               }
            }

         } else {
            rct.lastSample = value;
            rct.curRepetitions = 1;
         }
      }

      //
      // Run 'adaptive proportion' test
      //
      if (!apt.isInitialized) {
         apt.isInitialized = true;
         apt.firstSample = value;
         apt.curRepetitions = 0;
         apt.curSamples = 0;
      } else {
         if (++apt.curSamples >= apt.windowSize) {
            apt.isInitialized = false;
            if (apt.curRepetitions > apt.cutoffValue) {
               // Check to see if we have reached the failure threshold
               totalAptFailuresForCurrentDevice++;
               if (++apt.cycleFailures > numFailuresThreshold) {
                  if (apt.statusByte == 0) {
                     apt.statusByte = apt.signature;
                  }
               }

               if (apt.cycleFailures > maxAptFailuresPerBlock) {
                  // Record the maximum failures per block for reporting
                  maxAptFailuresPerBlock = apt.cycleFailures;
               }

               if (debugMode) {
                  if (apt.cycleFailures >= 1) {
                     pr_info("apt.cycleFailures: %d value: %d\n", apt.cycleFailures, value);
                  }
               }

            }
         } else {
            if (apt.firstSample == value) {
               ++apt.curRepetitions;
            }
         }
      }
   }
}

/**
 * A function to initialize the repetition count test
 *
 */
static void rct_initialize(void)
{
   memset(&rct, 0x00, sizeof(rct));
   rct.statusByte = 0;
   rct.signature = 1;
   rct.maxRepetitions = 5;
   rct_restart();
}

/**
 * A function to restart the repetition count test
 *
 */
static void rct_restart(void)
{
   rct.isInitialized = false;
   rct.curRepetitions = 1;
   rct.failureCount = 0;
}

/**
 * A function to initialize the adaptive proportion test
 *
 */
static void apt_initialize(void)
{
   memset(&apt, 0x00, sizeof(apt));
   apt.statusByte = 0;
   apt.signature = 2;
   apt.windowSize = 64;
   apt.cutoffValue = 5;
   apt_restart();
}

/**
 * A function to restart the adaptive proportion test
 *
 */
static void apt_restart(void)
{
   apt.isInitialized = false;
   apt.cycleFailures = 0;
}

/*
 * A function for handling module loading event and for allocating resources.
 *
 * @return 0 - successful operation, otherwise the error code (a negative number)
 */
static int __init init_swrandom(void)
{
   int usb_result;
   int err;

   err = 0;
   usbData = NULL;
   buffRndIn = NULL;
   buffTRndOut = NULL;

   rct_initialize();
   apt_initialize();

   if (bytesPerSample <= 0 || bytesPerSample > TRND_OUT_BUFFSIZE) {
      pr_err("%s: init_swrandom(): Bytes per second parameter %d is not valid, it must be between 1 and 16000\n", DRIVER_NAME, bytesPerSample);
      return -EINVAL;
   }

   if (powerProfile < 0 || powerProfile > 9) {
      pr_err("%s: init_swrandom(): Power profile parameter %d is not valid, it must be between 0 and 9\n", DRIVER_NAME, (int)powerProfile);
      return -EINVAL;
   }

   if (!strcmp("SHA256", postProcessingMethod) || !strcmp("", postProcessingMethod)) {
      postProcessingMethodId = SHA256_PP_METHOD;
   } else if (!strcmp("SHA512", postProcessingMethod)) {
      postProcessingMethodId = SHA512_PP_METHOD;
   } else if (!strcmp("xorshift64", postProcessingMethod)) {
      postProcessingMethodId = XORSHIFT64_PP_METHOD;
   } else {
      pr_err("%s: init_swrandom(): Post processing method %s is not valid\n", DRIVER_NAME, postProcessingMethod);
      return -EINVAL;
   }

   sha256_initializeSerialNumber(413145);
   if (sha256_selfTest() != SUCCESS) {
      pr_err("%s: init_swrandom(): Post processing logic SHA256 failed the self-test\n", DRIVER_NAME);
      return -EPERM;
   }

   if (sha512_selfTest() != SUCCESS) {
      pr_err("%s: init_swrandom(): Post processing logic SHA512 failed the self-test\n", DRIVER_NAME);
      return -EPERM;
   }

   if (xorshift64_selfTest() != SUCCESS) {
      pr_err("%s: init_swrandom(): Post processing logic xorshift64 failed the self-test\n", DRIVER_NAME);
      return -EPERM;
   }

   err = create_proc();
   if (err != SUCCESS) {
      pr_err("init_swrandom: could not create /proc/%s directory\n", DEVICE_NAME);
      return err;
   }

   err = init_char_dev();
   if (err != SUCCESS) {
      pr_err("%s: init_swrandom(): Could not initialize char device %s\n", DRIVER_NAME, DEVICE_NAME);
      remove_proc();
      return err;
   }

   // Initialize buffers and structures

   acmCtxt = kmalloc(sizeof(struct acm_context), GFP_KERNEL);
   if (acmCtxt == NULL) {
      pr_err("%s: init_swrandom(): Could not allocate bytes for the acm_context structure\n", DRIVER_NAME);
      err = -ENOMEM;
      goto acm_ctxt_mem_err;
   }

   buffRndIn = kmalloc(RND_IN_BUFFSIZE + 1, GFP_KERNEL);
   if (buffRndIn == NULL) {
      pr_err("%s: init_swrandom(): Could not allocate kernel bytes for the random input buffer\n", DRIVER_NAME);
      err = -ENOMEM;
      goto in_buff_mem_err;
   }

   buffTRndOut = kmalloc(TRND_OUT_BUFFSIZE, GFP_KERNEL);
   if (buffTRndOut == NULL) {
      pr_err("%s: init_swrandom(): Could not allocate kernel bytes for the random output buffer\n", DRIVER_NAME);
      err = -ENOMEM;
      goto out_buff_mem_err;
   }

   ctrlData = kmalloc(sizeof(struct ctrl_data), GFP_KERNEL);
   if (ctrlData == NULL) {
      pr_err("%s: init_swrandom(): Could not allocate kernel bytes for the control data\n", DRIVER_NAME);
      err = -ENOMEM;
      goto ctrl_mem_err;
   }

   threadData = kzalloc(sizeof(struct kthread_data), GFP_KERNEL);
   if (threadData == NULL) {
      pr_err("%s: init_swrandom(): Could not allocate kernel bytes for the kthread data\n", DRIVER_NAME);
      err = -ENOMEM;
      goto thread_mem_err;
   }

   // Give priority to ACM/CDC type when probing for SwiftRNG devices.
   acm_device_probe();

   usb_result = usb_register(&usb_driver);
   if (usb_result < 0) {
      pr_err("%s: init_swrandom(): Could not register usb driver, error number %d\n", DRIVER_NAME, usb_result);
      err = usb_result;
      goto usb_register_err;
   }

   threadData->drv_thread = kthread_run(thread_function, threadData, "SwiftRNG driver thread");
   if (threadData->drv_thread) {
      init_completion(&threadData->to_thread_event);
      init_completion(&threadData->from_thread_event);
   } else {
      pr_err("%s: init_swrandom(): Could not create a SwiftRNG driver kernel thread\n", DRIVER_NAME);
      err = -EPERM;
      goto thread_create_err;
   }

   mutex_init(&dataOpLock);

   pr_info("%s: Char device %s registered successfully, module version: %s\n", DRIVER_NAME, DEVICE_NAME, DRIVER_VERSION);

   return SUCCESS;

thread_create_err:
   usb_deregister(&usb_driver);
usb_register_err:
   kfree(threadData);
thread_mem_err:
   kfree(ctrlData);
ctrl_mem_err:
   kfree(buffTRndOut);
out_buff_mem_err:
   kfree(buffRndIn);
in_buff_mem_err:
   kfree(acmCtxt);
acm_ctxt_mem_err:
   remove_proc();
   uninit_char_dev();
   return err;
}

/**
 * Read bytes from ACM device.
 *
 * @param size - amount of bytes to read
 * @param data - pointer to where the bytes should be saved
 * @param file - pointer to the file structure
 *
 * @return if >= 0 then number of bytes retrieved, a negative number indicates an error
 *
 */
static int acm_read(struct file *file, unsigned char *data, int size)
{
   unsigned long long offset = 0;
   if (file == NULL) {
      return -1;
   }

   return kernel_read(file, data, size, &offset);
}

/**
 * Keep reading bytes from ACM device until all of the expected bytes are retrieved.
 * Stop reading when there are no more bytes to retrieve or when there is a failure
 * condition.
 *
 * @param size - total amount of bytes to read
 * @param data - pointer to where the bytes should be saved
 * @param bytesTransfered - pointer to an actual bytes transfered
 *
 * @return 0 for successful operation, a negative number indicates an error.
 *
 */
static int acm_full_read(unsigned char *data, int size, int *bytesTransfered)
{
   int bytesReceived = 0;
   int totalBytesReceived = 0;

   while (totalBytesReceived < size) {
      bytesReceived = acm_read(acmCtxt->filed, data + totalBytesReceived, size - totalBytesReceived);
      if (bytesReceived < 0) {
         pr_err("%s: acm_full_read(): Could not receive data from ACM device\n", DRIVER_NAME);
         return -EPERM;
      }
      if (bytesReceived == 0) {
         return -EPERM;
      }
      totalBytesReceived += bytesReceived;
   }
   if (totalBytesReceived != size) {
      return -EPERM;
   }
   *bytesTransfered = totalBytesReceived;
   return SUCCESS;
}

/**
 * Write bytes to ACM device.
 *
 * @param size - amount of bytes to write
 * @param data - pointer to bytes to write
 * @param file - pointer to the file structure
 *
 * @return if >= 0 then number of bytes written, a negative number indicates an error
 *
 */
static int acm_write(struct file *file, const unsigned char *data, int size)
{
   unsigned long long offset = 0;

   if (file == NULL) {
      return -1;
   }

   return kernel_write(file, data, size, &offset);
}

/**
 * Close ACM device
 *
 * @param file - pointer to the file structure
 */
static void acm_close(struct file *file)
{
   if (file != NULL) {
      filp_close(file, NULL);
   }
}

/**
 * Open an ACM device
 *
 * @param flags - for example: O_RDWR
 * @param path - path to the device
 *
 * @return pointer to a file structure or NULL when error
 */
static struct file *acm_open(const char *path, int flags)
{
   struct file *filp = NULL;
   filp = filp_open(path, flags, 0);
   if (IS_ERR(filp)) {
      return NULL;
   }
   return filp;
}

/**
 * A function used for searching for SwiftRNG ACM devices
 */
static int acm_iterate_dir_callback(struct dir_context *ctx, const char *name, int nameLength, loff_t offset, u64 ino,
      unsigned int dType)
{
   struct acm_callback_context *buf = container_of(ctx, struct acm_callback_context, ctx);
   return buf->filler(buf->context, name, nameLength, offset, ino, dType);
}

/**
 * A function used when searching for SwiftRNG ACM devices
 *
 * @return 0 for successful operation
 */
static int acm_readdir(const char* path, acm_readdir_t filler, void* context)
{
   int res;
   struct acm_callback_context buf = { .ctx.actor = (filldir_t) acm_iterate_dir_callback, .context = context, .filler =
         filler };

   struct file* dir = filp_open(path, O_DIRECTORY, S_IRWXU | S_IRWXG | S_IRWXO);
   if (!IS_ERR(dir)) {

      res = iterate_dir(dir, &buf.ctx);
      filp_close(dir, NULL);
   } else {
      res = (int) PTR_ERR(dir);
   }
   return res;
}

/**
 * A function used when searching for SwiftRNG ACM devices
 */
static int acm_filldir_callback(void* data, const char *name, int nameLength, loff_t offset, u64 ino, unsigned int dType)
{
   if (nameLength >= ACM_DEV_NAME_BY_ID_LENGTH_LIMIT - 1) {
      pr_err("%s: acm_filldir_callback(): ACM device name too long\n", DRIVER_NAME);
      return 0;
   }
   if (acmCtxt->devices_found >= MAX_ACM_DEVICES_TO_PROBE) {
      pr_err("%s: acm_filldir_callback(): Exceeding max number of ACM devices\n", DRIVER_NAME);
      return 0;
   }
   memcpy(acmCtxt->dev_name_by_id[acmCtxt->devices_found], name, nameLength);
   acmCtxt->dev_name_by_id[acmCtxt->devices_found][nameLength] = '\0';
   if (strstr(acmCtxt->dev_name_by_id[acmCtxt->devices_found], "TectroLabs_SwiftRNG") != NULL) {
      acmCtxt->devices_found++;
   }
   return 0;
}

/**
 * Search for suitable ACM device
 *
 * @return true if at least one device is found
 */
static bool acm_search_for_device(void)
{
   acm_readdir(dev_serial_by_id_path, acm_filldir_callback, (void*) 1);
   if (!acmCtxt->devices_found) {
      pr_info("%s: No SwiftRNG CDC/ACM device found\n", DRIVER_NAME);
      return false;
   }
   return true;
}

/**
 * Initialize control data for probe operations.
 */
static void probe_init(void)
{
   ctrlData->isPowerProfileSet = false;
   ctrlData->isVersionRetrieved = false;
   ctrlData->isModelRetrieved = false;
   ctrlData->isSNRetrieved = false;
   // Reset TRNG buffer index
   curTrngOutIdx = TRND_OUT_BUFFSIZE;
}

/**
 * Probe for SwiftRNG ACM devices.
 *
 * @return true if device is found and ready for usage
 */
static bool acm_device_probe(void)
{
   int op_status = 0;
   int i;

   if (acmCtxt == NULL) {
      pr_err("%s: acm_device_probe(): BUG: acmCtxt not initialized\n", DRIVER_NAME);
      return false;
   }

   if (usbData != NULL) {
      pr_err("%s: acm_device_probe(): BUG: probing for ACM devices while bulk USB is still active\n", DRIVER_NAME);
      return false;
   }

   if (isEntropySrcRdy) {
      pr_err("%s: acm_device_probe(): BUG: probing for ACM devices with an entropy source active\n", DRIVER_NAME);
      return false;
   }

   // Clear the ACM context
   memset(acmCtxt, 0, sizeof(struct acm_context));
   probe_init();

   if (!acm_search_for_device()) {
      return false;
   }

   for (i = 0; i < acmCtxt->devices_found; ++i) {

      strcpy(acmCtxt->dev_name, dev_serial_by_id_path);
      if (debugMode) {
         pr_info("found SwiftRNG device: %s\n", acmCtxt->dev_name_by_id[i]);
      }
      strcat(acmCtxt->dev_name, "/");
      strcat(acmCtxt->dev_name, acmCtxt->dev_name_by_id[i]);

      op_status = kern_path(acmCtxt->dev_name, LOOKUP_FOLLOW, &acmCtxt->path);
      if (op_status) {
         if (debugMode) {
            pr_err("%s: acm_device_probe(): kern_path() failed for %s\n", DRIVER_NAME, acmCtxt->dev_name);
         }
         continue;
      }
      acmCtxt->inode = acmCtxt->path.dentry->d_inode;
      acmCtxt->devt = acmCtxt->inode->i_rdev;

      if (!acm_set_tty_termios_flags()) {
         continue;
      }

      if (!acm_open_device()) {
         continue;
      }

      if (!acm_lock_device()) {
         acm_clean_up();
         continue;
      }

      if (debugMode) {
         pr_info("acm_context->devices_found: %d\n", acmCtxt->devices_found);
         pr_info("acm_context->device_open: %d\n", acmCtxt->device_open);
         pr_info("acm_context->device_locked: %d\n", acmCtxt->device_locked);
      }
      isEntropySrcRdy = true;

      log_device_connect_message();

      return true;
   }

   return false;
}

/**
 * Open ACM device
 *
 * @return true for successful operation
 */
static bool acm_open_device(void)
{
   acmCtxt->filed = acm_open(acmCtxt->dev_name, O_RDWR | O_NOCTTY | O_SYNC);
   if (acmCtxt->filed == NULL) {
      pr_info("%s: acm_open_device(): Could not open tty device: %s", DRIVER_NAME, acmCtxt->dev_name);
      return false;
   }
   acmCtxt->device_open = true;
   return true;
}

/**
 * Lock ACM device
 *
 * @return true for successful operation
 */
static bool acm_lock_device(void)
{
   int op_status;
   locks_init_lock(&acmCtxt->fl);
   acmCtxt->fl.fl_flags = FL_FLOCK | FL_EXISTS;
   acmCtxt->fl.fl_type = LOCK_READ | LOCK_WRITE;
   op_status = locks_lock_inode_wait(acmCtxt->inode, &acmCtxt->fl);
   if (op_status != 0) {
      pr_info("%s: acm_lock_device(): Could not lock device %s\n", DRIVER_NAME, acmCtxt->dev_name);
      return false;
   }
   acmCtxt->device_locked = true;
   return true;
}

/**
 * Set termios flags associated with the ACM tty device
 *
 * @return true for successful operation
 */
static bool acm_set_tty_termios_flags(void)
{
   bool successStatus = true;

#if LINUX_VERSION_CODE <= KERNEL_VERSION(5,11,22)
   acmCtxt->tty = tty_kopen(acmCtxt->devt);
#else
   acmCtxt->tty = tty_kopen_exclusive(acmCtxt->devt);
#endif

   if (IS_ERR(acmCtxt->tty)) {
      pr_info("%s: tty_kopen() failed for %s\n", DRIVER_NAME, acmCtxt->dev_name);
      return false;
   }

   acmCtxt->opts.c_lflag &= ~(ECHO | ECHONL | ICANON | ISIG | IEXTEN);
   acmCtxt->opts.c_iflag &= ~(INLCR | IGNCR | ICRNL | IXON | IXOFF);
   acmCtxt->opts.c_oflag &= ~(ONLCR | OCRNL);

   // Set time out to 100 milliseconds for read serial device operations
   acmCtxt->opts.c_cc[VTIME] = 1;
   acmCtxt->opts.c_cc[VMIN] = 0;

   if (tty_set_termios(acmCtxt->tty, &acmCtxt->opts) != 0) {
      pr_info("%s: acm_set_tty_termios_flags(): tty_set_termios() failed for %s\n", DRIVER_NAME, acmCtxt->dev_name);
      successStatus = false;
      goto close_free_tty;
   }

close_free_tty:
   tty_kclose(acmCtxt->tty);
   tty_kref_put(acmCtxt->tty);
   return successStatus;
}

/**
 * Clean up ACM data
 */
static void acm_clean_up(void)
{
   int op_status;

   if (acmCtxt == NULL) {
      pr_err("%s: acm_clean_up(): BUG: acmCtxt not initialized\n", DRIVER_NAME);
      return;
   }

   if (acmCtxt->device_locked) {
      acmCtxt->fl.fl_type = F_UNLCK;
      op_status = locks_lock_inode_wait(acmCtxt->inode, &acmCtxt->fl);
      if (op_status != 0) {
         pr_err("%s: acm_clean_up(): Could not unlock %s\n", DRIVER_NAME, acmCtxt->dev_name);
      }
      acmCtxt->device_locked = false;
      if (debugMode) {
         pr_info("acm_clean_up(): locks_lock_inode_wait() returned: %d\n", op_status);
      }
   }

   if (acmCtxt->device_open) {
      acm_close(acmCtxt->filed);
      acmCtxt->device_open = false;
   }

   if (usbData == NULL) {
      isEntropySrcRdy = false;
   }
}

/*
 * A function to handle module unloading event
 */
static void __exit exit_swrandom(void)
{
   isEntropySrcRdy = false;
   isShutDown = true;

   if (!completion_done(&threadData->to_thread_event)) {
      threadData->command = 'e';
      complete(&threadData->to_thread_event);
   }

   msleep(1000);
   wait_for_pending_ops();
   acm_clean_up();
   usb_deregister(&usb_driver);
   remove_proc();
   uninit_char_dev();
   clean_up_usb();
   kfree(buffRndIn);
   kfree(buffTRndOut);
   kfree(acmCtxt);
   kfree(ctrlData);
   kfree(threadData);
   mutex_destroy(&dataOpLock);
   pr_info("%s: exit_swrandom(): Char device %s unregistered successfully\n", DRIVER_NAME, DEVICE_NAME);
}

module_init( init_swrandom);
module_exit( exit_swrandom);
