/*
 * swrandom.c
 * ver. 1.10
 *
 */

/*
 * SwiftRNG device driver - 1.10
 *
 * Copyright (C) 2014-2020 TectroLabs, https://tectrolabs.com
 *
 * This is a 'swrandom' kernel module that registers a character device
 * for supplying true random bytes generated by SwiftRNG hardware
 * random number generators.
 *
 * Once the module is successfully built with 'make', it should be loaded
 * into the kernel by running the ins-swrandom.sh script:
 * sudo ./ins-swrandom.sh
 *
 * Use the following command to load the module with a different SwiftRNG
 * power profile number (in this example it will use power profile number 5):
 * sudo ./ins-swrandom.sh powerProfile=5
 *
 * For devices with versions 1.2 and up the post processing can be disabled.
 * To disable post processing use the following command:
 * sudo ./ins-swrandom.sh disablePostProcessing
 *
 * For devices with versions 1.2 and up Marsaglia's Xorshift64 method can be used
 * as a post processing method.
 * To enable Marsaglia's Xorshift64 use the following command:
 * sudo ./ins-swrandom.sh postProcessingMethod=xorshift64
 *
 * To enable SHA-512 post processing use the following command:
 * sudo ./ins-swrandom.sh postProcessingMethod=SHA512
 *
 * 'Repetition Count' and 'Adaptive Proportion' statistical tests can be disabled
 * with the following command:
 * sudo ./ins-swrandom.sh disableStatisticalTests
 *
 * After the module is successfully loaded by the kernel, the random bytes
 * will be available for download from the /dev/swrandom device.
 *
 * It can be used to feed the 'rngd' daemon with random data generated
 * by a SwiftRNG device using the following command:
 * sudo rngd -r /dev/swrandom
 *
 * Alternatively you can download the random byte stream into a file using
 * the following command:
 * dd if=/dev/swrandom of=download.bin bs=12000000 count=10
 *
 * The module will automatically detect when a SwiftRNG device is plugged
 * in or unplugged from any USB port.
 *
 * To verify if the 'swrandom' module has successfully detected the SW device,
 * simply check the kernel system logs, you should see a log that should
 * look similar to this:
 *
 *   -----------------------------------------
 *   -- SwiftRNG device connected and ready --
 *   -----------------------------------------
 *
 *
 */
#include "swrandom.h"

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Andrian Belinski");
MODULE_DESCRIPTION("A module that registers a device for supplying true random bytes generated by Hardware RNG SwiftRNG");
MODULE_VERSION("1.10");

module_param(powerProfile, short, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);
MODULE_PARM_DESC(powerProfile, "Power profile integer number between 0 and 9 (9 - highest power consumption and also the fastest generation speed)");

module_param(disablePostProcessing, bool, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);
MODULE_PARM_DESC(disablePostProcessing, "A flag to indicate if the post processing of raw data should be disabled.");

module_param(disableStatisticalTests, bool, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);
MODULE_PARM_DESC(disableStatisticalTests, "A flag to indicate if statistical tests for the raw data should be disabled.");

module_param(postProcessingMethod, charp, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);
MODULE_PARM_DESC(postProcessingMethod, "Post processing method to use. Valid options are: SHA256, SHA512 or xorshift64");

module_param(enableForGCP, bool, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);
MODULE_PARM_DESC(enableForGCP, "Use this flag when collecting random samples for Global Consciousness Project (GCP).");

module_param(bytesPerSample, int, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);
MODULE_PARM_DESC(bytesPerSample, "How many bytes to download per sample. Valid value must be between 1 and 16000. Providing this parameter may reduce performance.");

/**
 * A function to handle the event when the expected USB device is plugged in or connected
 *
 * @param struct usb_interface *interface - pointer to the usb_interface structure associated with the device
 * @param const struct usb_device_id *id -  pointer to the usb_device_id
 * @return 0 - successfully, otherwise the error code (a negative number)
 *
 */
static int usb_probe(struct usb_interface *interface, const struct usb_device_id *id) {
	struct usb_host_interface *iface_desc;
	struct usb_endpoint_descriptor *endpoint;
	int i;
	size_t buffer_size;
	int retval = SUCCESS;

	if(mutex_lock_killable(&dataOpLock) != SUCCESS) {
		printk(KERN_ALERT "Could not lock the mutex\n");
		return -EPERM;
	}

	if (isEntropySrcRdy || usbData != NULL) {
		printk(KERN_INFO "A SW USB device already registered\n");
		mutex_unlock(&dataOpLock);
		return -EPERM;
	}

	if (isShutDown) {
		printk(KERN_INFO "Cannot register USB device (%04X:%04X) while module is being removed from the kernel\n", id->idVendor, id->idProduct);
		mutex_unlock(&dataOpLock);
		return -EPERM;
	}

	iface_desc = interface->cur_altsetting;


	usbData = kmalloc(sizeof(struct usb_data), GFP_KERNEL);
	if (usbData == NULL) {
		printk(KERN_ALERT "Out of memory\n");
		mutex_unlock(&dataOpLock);
		return -ENOMEM;
	}
	memset(usbData, 0x00, sizeof (struct usb_data));
	usbData->isPowerProfileSet = false;
	usbData->isVersionRetrieved = false;

	usbData->udev = usb_get_dev(interface_to_usbdev(interface));
	usbData->interface = interface;


	for (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {
		endpoint = &iface_desc->endpoint[i].desc;

		if (!usbData->bulk_in_endpointAddr &&
		    (endpoint->bEndpointAddress & USB_DIR_IN) &&
		    ((endpoint->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK)
					== USB_ENDPOINT_XFER_BULK)) {
			buffer_size = endpoint->wMaxPacketSize;
			usbData->bulk_in_size = buffer_size;
			usbData->bulk_in_endpointAddr = endpoint->bEndpointAddress;
			usbData->bulk_in_buffer = kmalloc(USB_BUFFER_SIZE, GFP_KERNEL);
			if (usbData->bulk_in_buffer == NULL) {
				printk(KERN_ALERT "Could not allocate memory for bulk_in_buffer");
				retval = -ENOMEM;
				break;
			}
		}

		if (!usbData->bulk_out_endpointAddr &&
		    !(endpoint->bEndpointAddress & USB_DIR_IN) &&
		    ((endpoint->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK)
					== USB_ENDPOINT_XFER_BULK)) {
			buffer_size = endpoint->wMaxPacketSize;
			usbData->bulk_out_endpointAddr = endpoint->bEndpointAddress;
			usbData->bulk_out_buffer = kmalloc(buffer_size, GFP_KERNEL);
			if (usbData->bulk_out_buffer == NULL) {
				printk(KERN_ALERT "Could not allocate memory for bulk_out_buffer");
				retval = -ENOMEM;
				break;
			}
		}
	}

	if (retval == SUCCESS) {
		usbData->statusByteHolder = kmalloc(1, GFP_KERNEL);
		if (usbData->statusByteHolder == NULL) {
			printk(KERN_ALERT "Could not allocate memory for statusByteHolder buffer");
			retval = -ENOMEM;
		}
	}

	if (retval == SUCCESS) {
		usbData->deviceVersion = kmalloc(5, GFP_KERNEL);
		if (usbData->deviceVersion == NULL) {
			printk(KERN_ALERT "Could not allocate memory for deviceVersion buffer");
			retval = -ENOMEM;
		}
	}

	if (retval == SUCCESS && !(usbData->bulk_in_endpointAddr && usbData->bulk_out_endpointAddr)) {
		printk(KERN_INFO "Could not find both bulk-in and bulk-out endpoints");
		retval = -EPERM;
	}
	if (retval != SUCCESS) {
		clean_up_usb();
	} else {
		printk(KERN_INFO "-----------------------------------------\n");
		printk(KERN_INFO "-- SwiftRNG device connected and ready --\n");
		printk(KERN_INFO "-----------------------------------------\n");
		#ifdef inDebugMode
		printk(KERN_INFO "Device is using IN bulk address %02X, OUT bulk address %02X, bulk IN size: %d\n", usbData->bulk_in_endpointAddr, usbData->bulk_out_endpointAddr, (int)usbData->bulk_in_size);
		#endif
		isEntropySrcRdy = true;
	}

	mutex_unlock(&dataOpLock);
	return retval;
}
/**
 * A function to handle the event when the USB device is unplugged in or disconnected
 *
 * @param struct usb_interface *interface - pointer to the usb_interface structure associated with the device
 *
 */
static void usb_disconnect(struct usb_interface *interface) {
	if(mutex_lock_killable(&dataOpLock) != SUCCESS) {
		printk(KERN_INFO "Could not lock the mutex\n");
	}

	isEntropySrcRdy = false;
	clean_up_usb();
	printk(KERN_INFO "USB device disconnected\n");
	mutex_unlock(&dataOpLock);
}

/**
 * A function to clean-up the USB allocated resources
 *
 *
 */

static void clean_up_usb(void) {
	if (usbData != NULL) {
		if ( usbData->bulk_out_buffer != NULL) {
			kfree(usbData->bulk_out_buffer);
			usbData->bulk_out_buffer = NULL;
		}
		if ( usbData->bulk_in_buffer != NULL) {
			kfree(usbData->bulk_in_buffer);
			usbData->bulk_in_buffer = NULL;
		}
		if ( usbData->statusByteHolder != NULL) {
			kfree(usbData->statusByteHolder);
			usbData->statusByteHolder = NULL;
		}
		if ( usbData->deviceVersion != NULL) {
			kfree(usbData->deviceVersion);
			usbData->deviceVersion = NULL;
		}
		kfree(usbData);
		usbData = NULL;
	}
}

/**
 * A function to handle the event when device is open
 *
 * @param struct inode *inode - pointer to the inode structure of the caller
 * @param struct file *file -  pointer to the file structure of the caller
 * @return 0 - successfully, otherwise the error code (a negative number)
 *
 */
static int device_open(struct inode *inode, struct file *file)
{
	int status = SUCCESS;
	unsigned int mj = imajor(inode);
	unsigned int mn = iminor(inode);

	if (mj != major || mn != minor) {
		printk(KERN_ALERT "No device found with major=%d and minor=%d\n", mj, mn);
		return -ENODEV;
	}

	if (!isEntropySrcRdy || isShutDown) {
		status = -ENODATA;
	}

	return status;
}

/**
 * A function to handle the event when device is closed
 *
 * @param struct inode *inode - pointer to the inode structure of the caller
 * @param struct file *file -  pointer to the file structure of the caller
 * @return 0 - successfully, otherwise the error code (a negative number)
 *
 */
static int device_release(struct inode *inode, struct file *file)
{
	return SUCCESS;
}

/**
 * A function to handle the event when caller requests a device read operation
 *
 * @param struct file *file - pointer to the file structure of the caller
 * @param char __user *buffer - pointer to the buffer in the user space
 * @param size_t length - size in bytes for the read operation
 * @param loff_t * offset
 * @return greater than 0 - number of bytes actually read, otherwise the error code (a negative number)
 *
 */
static ssize_t device_read(struct file *file, char __user *buffer, size_t length, loff_t * offset)
{
	ssize_t retval = SUCCESS;
	size_t act;
	size_t total;

	if(mutex_lock_killable(&dataOpLock) != SUCCESS) {
		printk(KERN_ALERT "Could not lock the mutex\n");
		return -EPERM;
	}


	if (!isEntropySrcRdy || isShutDown) {
		retval = -ENODATA;
	} else {
		isDeviceOpPending = true;
		total = 0;
		do {
			retval = get_entropy_bytes();
			if (retval == SUCCESS) {
				act = TRND_OUT_BUFFSIZE - curTrngOutIdx;
				if (act > (length - total)) {
					act = (length - total);
				}
				if (copy_to_user(buffer + total, buffTRndOut + curTrngOutIdx, act)) {
					retval = -EFAULT;
					break;
				} else {
					curTrngOutIdx += act;
					total += act;
					retval = total;
				}
			} else {
				break;
			}
		} while (total < length);
	#ifdef inDebugMode
		if (total > length) {
			printk(KERN_ALERT "Expected %d bytes to read and actually got %d \n", (int)length, (int)total);
		}
	#endif

	}
	isDeviceOpPending = false;
	mutex_unlock(&dataOpLock);
	return retval;
}

/**
 * Set device power profile, an integer number between 0 and 9
 * (9 - highest power consumption and also the fastest generation speed)");
 *
 * @return 0 - successful operation, otherwise the error code (a negative number)
 *
 */
static int set_device_power_profile(void) {
	int retval;

	// Send power profile command to the SW device
	usbData->bulk_out_buffer[0] = '0' + powerProfile;
	retval = snd_rcv_usb_data(usbData->bulk_out_buffer, 1,
			usbData->statusByteHolder, 0, 10);

	return retval;
}

/**
 * Configure statistical tests
 *
 */
static void configure_tests(void) {
	switch(usbData->deviceVersionLong) {
		case 11:
			numFailuresThreshold = 6;
			break;
		case 10:
			numFailuresThreshold = 9;
			break;
		default:
			numFailuresThreshold = 4;
			break;
	}
}

/**
 * Check to see if post processing is enabled for the device
 *
 * @return true - post processing is enabled, false otherwise
 *
 */
static bool is_post_processing_enabled(void) {

	if ((usbData->deviceVersionLong >= 12 && disablePostProcessing)
			|| (usbData->deviceVersionLong >= 20 && !strcmp("", postProcessingMethod))) {
		// Can only disable post processing for devices with version 1.2 and up
		return false;
	}
	return true;
}

/**
 * Check to see if post processing method xosrshift64 is enabled for the device
 *
 * @return true - post processing is enabled, false otherwise
 *
 */
static bool is_xorshift64_enabled(void) {

	if (usbData->deviceVersionLong >= 12 && postProcessingMethodId == XORSHIFT64_PP_METHOD) {
		// Can only use xorshift64 for devices with version 1.2 and up
		return true;
	}
	return false;
}

/**
 * Retrieve device version number.
 *
 * @return 0 - successful operation, otherwise the error code (a negative number)
 *
 */
static int get_device_version(void) {
	int retval;
	long highVersion;
	long lowVersion;

	// get device version
	usbData->bulk_out_buffer[0] = 'v';
	retval = snd_rcv_usb_data(usbData->bulk_out_buffer, 1,
			usbData->deviceVersion, 4, 10);

	if (retval == SUCCESS) {
		usbData->deviceVersion[4] = '\0';
		usbData->deviceVersion[2] = '\0';
		retval = kstrtol(usbData->deviceVersion + 1, 10, &highVersion);
		if (retval == SUCCESS) {
			retval = kstrtol(usbData->deviceVersion + 3, 10, &lowVersion);
		}
		if (retval == SUCCESS) {
			usbData->deviceVersionLong = highVersion * 10 + lowVersion;
		}
	}
	return retval;
}

/**
 * A function to request new entropy bytes when running out of entropy in the local buffer
 *
 * @return 0 - successful operation, otherwise the error code (a negative number)
 *
 */
static int get_entropy_bytes(void) {
	int status;
	if(curTrngOutIdx >= TRND_OUT_BUFFSIZE) {
		status = rcv_rnd_bytes();
	} else {
		status = SUCCESS;
	}
	return status;
}

/**
 * A function to fill the buffer with new entropy bytes
 *
 * @return 0 - successful operation, otherwise the error code (a negative number)
 *
 */
static int rcv_rnd_bytes(void) {
	int retval;
   	uint16_t byteCnt;
   	int i,j;
	uint32_t *dst32, *src32;
	uint64_t *dst64, *src64;


	if (!isEntropySrcRdy || isShutDown) {
		return -EPERM;
	}

	isUsbOpPending = true;
	retval = SUCCESS;

	if (usbData->isPowerProfileSet == false) {
		retval = set_device_power_profile();
		if (retval == SUCCESS) {
			usbData->isPowerProfileSet = true;
			printk(KERN_INFO "SwiftRNG device power profile has been set to %d \n", powerProfile);
		} else {
			retval = -EPERM;
		}
	}

	if (usbData->isVersionRetrieved == false) {
		retval = get_device_version();
		// Initialize RCT and APT statistical tests
		rct_initialize();
		apt_initialize();
		if (retval == SUCCESS) {
			usbData->isVersionRetrieved = true;
			printk(KERN_INFO "SwiftRNG device version: %ld \n", usbData->deviceVersionLong);
			if (is_post_processing_enabled() == true) {
				printk(KERN_INFO "SwiftRNG post processing is currently enabled\n");
				if (is_xorshift64_enabled() == true) {
					printk(KERN_INFO "SwiftRNG post processing method: Marsaglia's Xorshift64\n");
				} else if (postProcessingMethodId == SHA512_PP_METHOD) {
					printk(KERN_INFO "SwiftRNG post processing method: SHA-512\n");
				} else {
					printk(KERN_INFO "SwiftRNG post processing method: SHA-256\n");
				}
			} else {
				printk(KERN_INFO "SwiftRNG post processing is currently disabled\n");
			}
		} else {
			retval = -EPERM;
		}
		if (disableStatisticalTests) {
			printk(KERN_INFO "SwiftRNG statistical tests are currently disabled\n");
		} else {
			printk(KERN_INFO "SwiftRNG statistical tests are currently enabled\n");
		}

		configure_tests();
	}

	if (retval == SUCCESS) {
    	byteCnt = RND_IN_BUFFSIZE;

    	usbData->bulk_out_buffer[0] = 'x';

    	retval = snd_rcv_usb_data(usbData->bulk_out_buffer, 1, buffRndIn, RND_IN_BUFFSIZE, USB_READ_TIMEOUT_SECS);
    	if (retval == SUCCESS) {
    		if (!disableStatisticalTests) {
        		rct_restart();
        		apt_restart();
    			test_samples();
    		}
    		if (is_post_processing_enabled() == true) {
    			if (is_xorshift64_enabled() == true) {
    				memcpy(buffTRndOut, buffRndIn, TRND_OUT_BUFFSIZE);
    				xorshift64_postProcess((uint8_t *)buffTRndOut, TRND_OUT_BUFFSIZE);
    			} else if (postProcessingMethodId == SHA512_PP_METHOD) {
    				dst64 = (uint64_t *)buffTRndOut;
    				src64 = (uint64_t *)buffRndIn;
					for (i = 0; i < RND_IN_BUFFSIZE / (WORD_SIZE_BYTES * 2); i += MIN_INPUT_NUM_WORDS) {
						for (j = 0; j < MIN_INPUT_NUM_WORDS; j++) {
							srcToHash64[j] = src64[i+j];
						}
						sha512_generateHash(srcToHash64, MIN_INPUT_NUM_WORDS, dst64);
						dst64 += OUT_NUM_WORDS;
					}
    			} else {
    				dst32 = (uint32_t *)buffTRndOut;
    				src32 = (uint32_t *)buffRndIn;
					for (i = 0; i < RND_IN_BUFFSIZE / WORD_SIZE_BYTES; i += MIN_INPUT_NUM_WORDS) {
						for (j = 0; j < MIN_INPUT_NUM_WORDS; j++) {
							srcToHash32[j] = src32[i+j];
						}
						sha256_stampSerialNumber(srcToHash32);
						sha256_generateHash(srcToHash32, MIN_INPUT_NUM_WORDS + 1, dst32);
						dst32 += OUT_NUM_WORDS;
					}

    			}
    		} else {
    			memcpy(buffTRndOut, buffRndIn, TRND_OUT_BUFFSIZE);
    		}
		curTrngOutIdx = TRND_OUT_BUFFSIZE - bytesPerSample;
    		if (rct.statusByte != SUCCESS) {
    			printk(KERN_ALERT "Repetition Count Test failure\n");
    			retval = -EPERM;
    		} else if (apt.statusByte != SUCCESS) {
    			printk(KERN_ALERT "Adaptive Proportion Test failure\n");
    			retval = -EPERM;
    		}
    	}
	}

	isUsbOpPending = false;
	return retval;
}

/**
 * Send a SW device command and receive response
 *
 * @param char *snd -  a pointer to the command
 * @param int sizeSnd - how many bytes in command
 * @param char *rcv - a pointer to the data receive buffer
 * @param int sizeRcv - how many bytes expected to receive
 * @param int opTimeoutSecs - device read time out value in seconds
 *
 * @return 0 - successful operation, otherwise the error code (a negative number)
 *
 */
static int snd_rcv_usb_data(char *snd, int sizeSnd, char *rcv, int sizeRcv, int opTimeoutSecs) {
	int retry;
	int actualcCnt;
	int retval = SUCCESS;

	for (retry = 0; retry < USB_READ_MAX_RETRY_CNT; retry++) {
		if (isShutDown) {
			return -EPERM;
		}
		retval = usb_bulk_msg(usbData->udev, usb_sndbulkpipe(usbData->udev, usbData->bulk_out_endpointAddr), snd, sizeSnd, &actualcCnt, HZ*10);
		if (retval == SUCCESS && actualcCnt == sizeSnd) {
			retval = chip_read_data(rcv, sizeRcv + 1, opTimeoutSecs);
			if (retval == SUCCESS) {
				if (rcv[sizeRcv] != 0) {
					retval = -EFAULT;
					printk(KERN_ALERT "SW RNG internal failure: received device status code %d\n", rcv[sizeRcv]);
				} else {
					break;
				}
			}
		} else {
			#ifdef inDebugMode
				printk(KERN_INFO "It was an error during data communication. Cleaning up the receiving queue and continue.\n");
			#endif
			chip_read_data(rcv, sizeRcv + 1, opTimeoutSecs);
		}
	}
	if (retry >= USB_READ_MAX_RETRY_CNT) {
		retval = -ETIMEDOUT;
	}
	return retval;
}

/**
 * A function to handle SW device receive command
 * @param char *buff - a pointer to the data receive buffer
 * @param int length - how many bytes expected to receive
 * @param int opTimeoutSecs - device read time out value in seconds

 * @return 0 - successful operation, otherwise the error code (a negative number)
 *
 */
static int chip_read_data(char *buff, int length, int opTimeoutSecs) {
	long secsWaited;
	int transferred;
	time_t start, end;
	int cnt;
	int i;
	int retval;

	start = get_seconds();

	cnt = 0;
	do {
		if (isShutDown) {
			return -EPERM;
		}
		retval = usb_bulk_msg(usbData->udev, usb_rcvbulkpipe(usbData->udev, usbData->bulk_in_endpointAddr), usbData->bulk_in_buffer, length, &transferred, HZ*20);
		#ifdef inDebugMode
			printk(KERN_INFO "chip_read_data retval %d transferred %d, length %d\n", retval, transferred, length);
		#endif
		if (retval) {
			return retval;
		}

		if (transferred > USB_BUFFER_SIZE) {
			printk(KERN_ALERT "Received unexpected bytes when processing USB device request\n");
			return -EFAULT;
		}

		end = get_seconds();
		secsWaited = end - start;
		if (transferred > 0) {
			for (i = 0; i < transferred; i++) {
				buff[cnt++] = usbData->bulk_in_buffer[i];
			}
		}
	} while ( cnt < length && secsWaited < opTimeoutSecs);

	if (cnt != length) {
		#ifdef inDebugMode
			printk(KERN_INFO "timeout received, cnt %d\n", cnt);
		#endif
		return -ETIMEDOUT;
	}

	return SUCCESS;
}

/**
 * A function to handle the event when caller requests a device write operation
 *
 * @param struct file *file - pointer to the file structure of the caller
 * @param char __user *buff - pointer to the buffer in the user space
 * @param size_t len - size in bytes for the read operation
 * @param loff_t * off
 * @return greater than 0 - number of bytes actually written, otherwise the error code (a negative number)
 *
 */
static ssize_t device_write(struct file *file, const char *buff, size_t len, loff_t * off)
{
	return -EPERM;
}

/**
 * A function to handle the event when caller requests file seek operation
 *
 * @param struct file *file - pointer to the file structure of the caller
 * @param off_t off - seek position
 * @param int whence - seek mode
 * @return greater than 0 - new offset position, otherwise the error code (a negative number)
 *
 */
static loff_t device_llseek(struct file *filp, loff_t off, int whence)
{
	return -EPERM;
}

/*
 * A function for handling module loading event
 * @return greater than 0 - number of bytes actually read, otherwise the error code (a negative number)
 */
static int __init init_swrandom(void)
{
	int usb_result;
	int err;

	err = 0;
	usbData = NULL;
	buffRndIn = NULL;
	buffTRndOut = NULL;

	mutex_init(&dataOpLock);

	rct_initialize();
	apt_initialize();

	if (enableForGCP) {
		bytesPerSample = 256;
	} else if (bytesPerSample <= 0 || bytesPerSample > TRND_OUT_BUFFSIZE) {
		printk(KERN_ALERT "Bytes per second parameter %d is not valid, it must be between 1 and 16000\n", bytesPerSample);
		return -EINVAL;
	}

	if (powerProfile < 0 || powerProfile > 9)
	{
		printk(KERN_ALERT "Power profile parameter %d is not valid, it must be between 0 and 9\n", (int)powerProfile);
		return -EINVAL;
	}

	if (!strcmp("SHA256", postProcessingMethod) || !strcmp("", postProcessingMethod)) {
		postProcessingMethodId = SHA256_PP_METHOD;
	} else if (!strcmp("SHA512", postProcessingMethod)) {
		postProcessingMethodId = SHA512_PP_METHOD;
	} else if (!strcmp("xorshift64", postProcessingMethod)) {
		postProcessingMethodId = XORSHIFT64_PP_METHOD;
	} else {
		printk(KERN_ALERT "Post processing method %s is not valid\n", postProcessingMethod);
		return -EINVAL;
	}

	sha256_initializeSerialNumber(413145);
	if (sha256_selfTest() != SUCCESS) {
		printk(KERN_ALERT "Post processing logic SHA256 failed the self-test\n");
		return -EPERM;
	}

	if (sha512_selfTest() != SUCCESS) {
		printk(KERN_ALERT "Post processing logic SHA512 failed the self-test\n");
		return -EPERM;
	}

	if (xorshift64_selfTest() != SUCCESS) {
		printk(KERN_ALERT "Post processing logic xorshift64 failed the self-test\n");
		return -EPERM;
	}

	err = init_char_dev();
	if (err != SUCCESS) {
		printk(KERN_ALERT "Could not initialize char device %s\n", DEVICE_NAME);
		return err;
	}

	// Initialize buffers
	buffRndIn = kmalloc(RND_IN_BUFFSIZE + 1, GFP_KERNEL);
	if (buffRndIn == NULL) {
		printk(KERN_ALERT "Could not allocate %d kernel bytes for the random input buffer\n", RND_IN_BUFFSIZE);
		//unregister_chrdev(major, DEVICE_NAME);
		uninit_char_dev();
		return -ENOMEM;
	}

	buffTRndOut = kmalloc(TRND_OUT_BUFFSIZE, GFP_KERNEL);
	if (buffTRndOut == NULL) {
		printk(KERN_ALERT "Could not allocate %d kernel bytes for the random output buffer\n", TRND_OUT_BUFFSIZE);
		//unregister_chrdev(major, DEVICE_NAME);
		uninit_char_dev();
		kfree(buffRndIn);
		return -ENOMEM;
	}

	usb_result = usb_register(&usb_driver);
	if (usb_result < 0) {
		printk(KERN_ALERT "Could not register usb driver, error number %d\n", usb_result);
		//unregister_chrdev(major, DEVICE_NAME);
		uninit_char_dev();
		kfree(buffRndIn);
		kfree(buffTRndOut);
		return usb_result;
	}

	printk(KERN_INFO "Char device %s registered successfully with the major number %d, module version: %s\n", DEVICE_NAME, major, DEVICE_VERSION);
	return SUCCESS;
}

/**
 * Initialize the character device
 *
 * $return int - SUCCESS or error number
 *
 */
static int init_char_dev(void) {
	int error;
	int devices_to_destroy;
	dev_t dev;

	error = SUCCESS;
	dev = 0;
	devices_to_destroy = 0;

	error = alloc_chrdev_region(&dev, 0, 1, DEVICE_NAME);
	if (error < 0) {
		printk(KERN_ALERT "alloc_chrdev_region() call failed with error: %d\n", error);
		return error;
	}
	major = MAJOR(dev);

	dev_class = class_create(THIS_MODULE, DEVICE_NAME);
	if (IS_ERR(dev_class)) {
		error = PTR_ERR(dev_class);
		goto fail;
	}

	cdv = (struct cdev *)kzalloc(sizeof(struct cdev), GFP_KERNEL);
	if (cdv == NULL) {
		error = -ENOMEM;
		goto fail;
	}

	error = create_device();
	if (error) {
		goto fail;
	}

	return error;

fail:
	uninit_char_dev();
	return error;

}

/**
 * Create the device
 *
 * $return int - SUCCESS or error number
 */
static int create_device(void) {
	int error;
	dev_t devno;
	struct device *device;

	error = SUCCESS;
	device = NULL;
	devno = MKDEV(major, minor);
	cdev_init(cdv, &fops);
	cdv->owner = THIS_MODULE;
	error = cdev_add(cdv, devno, 1);
	if (error)
	{
		printk(KERN_ALERT "cdev_add() call failed with error: %d\n", error);
		return error;
	}
	device = device_create(dev_class, NULL, devno, NULL, DEVICE_NAME);
	if (IS_ERR(device)) {
		error = PTR_ERR(device);
		printk(KERN_ALERT "device_create() failed with error: %d\n", error);
		return error;
	}

	return error;
}

/**
 * Un-initialize the character device
 *
 */
static void uninit_char_dev(void) {
	// Get rid of the device
	if (cdv) {
		device_destroy(dev_class, MKDEV(major, minor));
		cdev_del(cdv);
		kfree(cdv);
	}
	if (dev_class) {
		class_destroy(dev_class);
	}
	unregister_chrdev_region(MKDEV(major, 0), 1);
}

/*
 * A function to handle event for module unloading
 */
static void __exit exit_swrandom(void)
{
	isEntropySrcRdy = false;
	isShutDown = true;
	msleep(2000);
	wait_for_pending_ops();
	usb_deregister(&usb_driver);
	//unregister_chrdev(major, DEVICE_NAME);
	uninit_char_dev();
	kfree(buffRndIn);
	kfree(buffTRndOut);
	mutex_destroy(&dataOpLock);
	printk(KERN_INFO "Char device %s unregistered successfully\n", DEVICE_NAME);
}

/**
 * A function to wait a little for any pending operations used when unloading the module
 *
 */
static void wait_for_pending_ops(void) {
	int cnt;
	for(cnt = 0; cnt < 100 && (isDeviceOpPending == true || isUsbOpPending == true); cnt++) {
		msleep(100);
	}
}

/**
 * Initialize the SHA256 data
 *
 */
static void sha256_initialize(void) {
	// Initialize H0, H1, H2, H3, H4, H5, H6 and H7
	sd.h0 = 0x6a09e667;
	sd.h1 = 0xbb67ae85;
	sd.h2 = 0x3c6ef372;
	sd.h3 = 0xa54ff53a;
	sd.h4 = 0x510e527f;
	sd.h5 = 0x9b05688c;
	sd.h6 = 0x1f83d9ab;
	sd.h7 = 0x5be0cd19;
}

/**
 * Initialize the SHA512 data
 *
 */
static void sha512_initialize(void) {
	int i;
	// Initialize H0, H1, H2, H3, H4, H5, H6 and H7
	sd5.h0 = 0x6a09e667f3bcc908;
	sd5.h1 = 0xbb67ae8584caa73b;
	sd5.h2 = 0x3c6ef372fe94f82b;
	sd5.h3 = 0xa54ff53a5f1d36f1;
	sd5.h4 = 0x510e527fade682d1;
	sd5.h5 = 0x9b05688c2b3e6c1f;
	sd5.h6 = 0x1f83d9abfb41bd6b;
	sd5.h7 = 0x5be0cd19137e2179;

	for (i = 0; i < 15; i++) {
		sd5.w[i] = 0;
	}
}


/**
 * Stamp a new serial number for the input data block into the last word
 *
 * @param void* inputBlock pointer to the input hashing block
 *
 */
static void sha256_stampSerialNumber(void *inputBlock)
{
	uint32_t *inw = (uint32_t*)inputBlock;
	inw[MIN_INPUT_NUM_WORDS] = sd.blockSerialNumber++;
}

/**
 * Initialize the serial number for hashing
 *
 * @param uint32_t initValue - a startup random number for generating serial number for hashing
 *
 */
static void sha256_initializeSerialNumber(uint32_t initValue) {
	sd.blockSerialNumber = initValue;
}

/**
 * Generate SHA256 value.
 *
 * @param uint32_t* src - pointer to an array of 32 bit words used as hash input
 * @param uint32_t dst - pointer to an array of 8 X 32 bit words used as hash output
 * @param int16_t len - number of 32 bit words available in array pointed by 'src'
 *
 * @return int 0 for successful operation, -1 for invalid parameters
 *
 */
static int sha256_generateHash(uint32_t *src, int16_t len, uint32_t *dst) {

	uint16_t blockNum;
	uint8_t ui8;
	int32_t initialMessageSize;
	uint16_t numCompleteDataBlocks;
	uint16_t reminder;
	uint16_t srcOffset;
	uint8_t needAdditionalBlock;
	uint8_t needToAddOneMarker;

	if (len <= 0) {
		return -1;
	}

	sha256_initialize();

	initialMessageSize = len * 8 * 4;
	numCompleteDataBlocks = len / maxDataBlockSizeWords;
	reminder = len % maxDataBlockSizeWords;

	// Process complete blocks
	for (blockNum = 0; blockNum < numCompleteDataBlocks; blockNum++) {
		srcOffset = blockNum * maxDataBlockSizeWords;
		for (ui8 = 0; ui8 < maxDataBlockSizeWords; ui8++) {
			sd.w[ui8] = src[ui8 + srcOffset];
		}
		// Hash the current block
		sha256_hashCurrentBlock();
	}

	srcOffset = numCompleteDataBlocks * maxDataBlockSizeWords;
	needAdditionalBlock = 1;
	needToAddOneMarker = 1;
	if (reminder > 0) {
		// Process the last data block if any
		ui8 = 0;
		for (; ui8 < reminder; ui8++) {
			sd.w[ui8] = src[ui8 + srcOffset];
		}
		// Append '1' to the message
		sd.w[ui8++] = 0x80000000;
		needToAddOneMarker = 0;
		if (ui8 < maxDataBlockSizeWords - 1) {
			for (; ui8 <  maxDataBlockSizeWords - 2; ui8++) {
				// Fill with zeros
				sd.w[ui8] = 0x0;
			}
			// add the message size to the current block
			sd.w[ui8++] = 0x0;
			sd.w[ui8] = initialMessageSize;
			sha256_hashCurrentBlock();
			needAdditionalBlock = 0;
		} else {
			// Fill the rest with '0'
			// Will need to create another block
			sd.w[ui8] = 0x0;
			sha256_hashCurrentBlock();
		}
	}

	if (needAdditionalBlock) {
		ui8 = 0;
		if (needToAddOneMarker) {
			sd.w[ui8++] = 0x80000000;
		}
		for (; ui8 <  maxDataBlockSizeWords - 2; ui8++) {
			sd.w[ui8] = 0x0;
		}
		sd.w[ui8++] = 0x0;
		sd.w[ui8] = initialMessageSize;
		sha256_hashCurrentBlock();
	}

	// Save the results
	dst[0] = sd.h0;
	dst[1] = sd.h1;
	dst[2] = sd.h2;
	dst[3] = sd.h3;
	dst[4] = sd.h4;
	dst[5] = sd.h5;
	dst[6] = sd.h6;
	dst[7] = sd.h7;

	return 0;
}

/**
 * Hash current block
 *
 */
static void sha256_hashCurrentBlock(void) {
	uint8_t t;

	// Process elements 16...63
	for (t = 16; t <= 63; t++) {
		sd.w[t] = sha256_sigma1(&sd.w[t-2]) + sd.w[t-7] + sha256_sigma0(&sd.w[t-15]) + sd.w[t-16];
	}

	// Initialize variables
	sd.a = sd.h0;
	sd.b = sd.h1;
	sd.c = sd.h2;
	sd.d = sd.h3;
	sd.e = sd.h4;
	sd.f = sd.h5;
	sd.g = sd.h6;
	sd.h = sd.h7;

	// Process elements 0...63
	for (t = 0; t <= 63; t++) {
		sd.tmp1 = sd.h + sha256_sum1(&sd.e) + sha256_ch(&sd.e, &sd.f, &sd.g) + k[t] + sd.w[t];
		sd.tmp2 = sha256_sum0(&sd.a) + sha256_maj(&sd.a, &sd.b, &sd.c);
		sd.h = sd.g;
		sd.g = sd.f;
		sd.f = sd.e;
		sd.e = sd.d + sd.tmp1;
		sd.d = sd.c;
		sd.c = sd.b;
		sd.b = sd.a;
		sd.a = sd.tmp1 + sd.tmp2;
	}

	// Calculate the final hash for the block
	sd.h0 += sd.a;
	sd.h1 += sd.b;
	sd.h2 += sd.c;
	sd.h3 += sd.d;
	sd.h4 += sd.e;
	sd.h5 += sd.f;
	sd.h6 += sd.g;
	sd.h7 += sd.h;
}

/**
 * FIPS PUB 180-4 section 4.1.2 formula (4.2)
 *
 * @param uint32_t* x pointer to variable x
 * @param uint32_t* y pointer to variable y
 * @param uint32_t* z pointer to variable z
 * $return uint32_t Ch value
 *
 */
static uint32_t sha256_ch(uint32_t *x, uint32_t *y, uint32_t *z) {
	return  ((*x) & (*y)) ^ (~(*x) & (*z));
}

/**
 * FIPS PUB 180-4 section 4.1.2 formula (4.3)
 *
 * @param uint32_t* x pointer to variable x
 * @param uint32_t* y pointer to variable y
 * @param uint32_t* z pointer to variable z
 * $return uint32_t Maj value
 *
 */
static uint32_t sha256_maj(uint32_t *x, uint32_t *y, uint32_t *z) {
	return ((*x) & (*y)) ^ ((*x) & (*z)) ^ ((*y) & (*z));
}

/**
 * FIPS PUB 180-4 section 4.1.2 formula (4.4)
 *
 * @param uint32_t* x pointer to variable x
 * $return uint32_t Sum0 value
 *
 */
static uint32_t sha256_sum0(uint32_t *x) {
	return ROTR(2, *x) ^ ROTR(13, *x) ^ ROTR(22, *x);
}

/**
 * FIPS PUB 180-4 section 4.1.2 formula (4.5)
 *
 * @param uint32_t* x pointer to variable x
 * $return uint32_t Sum1 value
 *
 */
static uint32_t sha256_sum1(uint32_t *x) {
	return ROTR(6, *x) ^ ROTR(11, *x) ^ ROTR(25, *x);
}

/**
 * FIPS PUB 180-4 section 4.1.2 formula (4.6)
 *
 * @param uint32_t* x pointer to variable x
 * $return uint32_t sigma0 value
 *
 */
static uint32_t sha256_sigma0(uint32_t *x) {
	return ROTR(7, *x) ^ ROTR(18, *x) ^ ((*x) >> 3);
}

/**
 * FIPS PUB 180-4 section 4.1.2 formula (4.7)
 *
 * @param uint32_t* x pointer to variable x
 * $return uint32_t sigma1 value
 *
 */
static uint32_t sha256_sigma1(uint32_t *x) {
	return ROTR(17, *x) ^ ROTR(19, *x) ^ ((*x) >> 10);
}

/**
 * FIPS PUB 180-4 section 4.1.3 formula (4.8)
 *
 * @param uint64_t* x pointer to variable x
 * @param uint64_t* y pointer to variable y
 * @param uint64_t* z pointer to variable z
 * $return uint64_t ch value
 *
 */
static uint64_t sha512_ch(uint64_t *x, uint64_t *y, uint64_t *z) {
	return  ((*x) & (*y)) ^ (~(*x) & (*z));
}

/**
 * FIPS PUB 180-4 section 4.1.3 formula (4.9)
 *
 * @param uint64_t* x pointer to variable x
 * @param uint64_t* y pointer to variable y
 * @param uint64_t* z pointer to variable z
 * $return uint64_t maj value
 *
 */
static uint64_t sha512_maj(uint64_t *x, uint64_t *y, uint64_t *z) {
	return ((*x) & (*y)) ^ ((*x) & (*z)) ^ ((*y) & (*z));
}

/**
 * FIPS PUB 180-4 section 4.1.3 formula (4.10)
 *
 * @param uint64_t* x pointer to variable x
 * $return uint64_t sum0 value
 *
 */
static uint64_t sha512_sum0(uint64_t *x) {
	return ROTR64(28, *x) ^ ROTR64(34, *x) ^ ROTR64(39, *x);
}

/**
 * FIPS PUB 180-4 section 4.1.3 formula (4.11)
 *
 * @param uint64_t* x pointer to variable x
 * $return uint64_t sum1 value
 *
 */
static uint64_t sha512_sum1(uint64_t *x) {
	return ROTR64(14, *x) ^ ROTR64(18, *x) ^ ROTR64(41, *x);
}

/**
 * FIPS PUB 180-4 section 4.1.3 formula (4.12)
 *
 * @param uint64_t* x pointer to variable x
 * $return uint64_t sigma0 value
 *
 */
static uint64_t sha512_sigma0(uint64_t *x) {
	return ROTR64(1, *x) ^ ROTR64(8, *x) ^ ((*x) >> 7);
}

/**
 * FIPS PUB 180-4 section 4.1.3 formula (4.13)
 *
 * @param uint64_t* x pointer to variable x
 * $return uint64_t sigma1 value
 *
 */
static uint64_t sha512_sigma1(uint64_t *x) {
	return ROTR64(19, *x) ^ ROTR64(61, *x) ^ ((*x) >> 6);
}

/**
 * Run the self test for checking the SHA256 algorithm implementation
 *
 * @return int 0 for successful operation
 *
 */
static int sha256_selfTest(void) {
	uint32_t results[8];
	int retVal;

	retVal = sha256_generateHash((uint32_t*)testSeq1, (uint16_t)11, (uint32_t*)results);
	if (retVal == 0) {
		// Compare the expected with actual results
		retVal = memcmp(results, exptHashSeq1, 8);
	}
	return retVal;
}

/*
 * A function for running the self test for the SHA512 post processing method
 *
 * @return 0 - successful operation, otherwise the error code (a negative number)
 *
 */
static int sha512_selfTest(void) {
	uint64_t results[8];
	int retVal;
	retVal = sha512_generateHash((uint64_t *)"8765432187654321876543218765432187654321876543218765432187654321", (uint16_t) 8, (uint64_t*) results);
	if (retVal == 0) {
		// Compare the expected with actual results
		retVal = memcmp(results, sha512_exptHashSeq1, 8);
	}
	return retVal;
}

/**
 * Generate SHA512 value.
 *
 * @param uint64_t* src - pointer to an array of 64 bit words used as hash input
 * @param uint64_t* dst - pointer to an array of 8 X 64 bit words used as hash output
 * @param int16_t len - number of 64 bit words available in array pointed by 'src'
 *
 * @return int 0 for successful operation, -1 for invalid parameters
 *
 */
static int sha512_generateHash(uint64_t *src, int16_t len, uint64_t *dst) {
	int i;

	if (len <= 0 || len > 14) {
		return -1;
	}

	sha512_initialize();

	for (i = 0; i < len; i++) {
		sd5.w[i] = src[i];
	}
	sd5.w[i] = 0x8000000000000000;
	sd5.w[15] = len * 64;


	sha512_hashCurrentBlock();

	// Save the results
	dst[0] = sd5.h0;
	dst[1] = sd5.h1;
	dst[2] = sd5.h2;
	dst[3] = sd5.h3;
	dst[4] = sd5.h4;
	dst[5] = sd5.h5;
	dst[6] = sd5.h6;
	dst[7] = sd5.h7;

	return 0;
}

/**
 * Hash current block
 *
 */
static void sha512_hashCurrentBlock(void) {

	uint8_t t;

	// Process elements 16...79
	for (t = 16; t <= 79; t++) {
		sd5.w[t] = sha512_sigma1(&sd5.w[t-2]) + sd5.w[t-7] + sha512_sigma0(&sd5.w[t-15]) + sd5.w[t-16];
	}

	// Initialize variables
	sd5.a = sd5.h0;
	sd5.b = sd5.h1;
	sd5.c = sd5.h2;
	sd5.d = sd5.h3;
	sd5.e = sd5.h4;
	sd5.f = sd5.h5;
	sd5.g = sd5.h6;
	sd5.h = sd5.h7;

	// Process elements 0...79
	for (t = 0; t <= 79; t++) {
		sd5.tmp1 = sd5.h + sha512_sum1(&sd5.e) + sha512_ch(&sd5.e, &sd5.f, &sd5.g) + sha512_k[t] + sd5.w[t];
		sd5.tmp2 = sha512_sum0(&sd5.a) + sha512_maj(&sd5.a, &sd5.b, &sd5.c);
		sd5.h = sd5.g;
		sd5.g = sd5.f;
		sd5.f = sd5.e;
		sd5.e = sd5.d + sd5.tmp1;
		sd5.d = sd5.c;
		sd5.c = sd5.b;
		sd5.b = sd5.a;
		sd5.a = sd5.tmp1 + sd5.tmp2;
	}

	// Calculate the final hash for the block
	sd5.h0 += sd5.a;
	sd5.h1 += sd5.b;
	sd5.h2 += sd5.c;
	sd5.h3 += sd5.d;
	sd5.h4 += sd5.e;
	sd5.h5 += sd5.f;
	sd5.h6 += sd5.g;
	sd5.h7 += sd5.h;
}


/**
 * Run the self test for checking the xorshift64 algorithm implementation
 *
 * @return int 0 for successful operation
 *
 */
static int xorshift64_selfTest(void) {
	uint64_t rawWord = 0x1212121212121212;
	uint64_t testWord = 0x2322d6d77d8b7b55;
	xorshift64_postProcess((uint8_t*)&rawWord, 8);

	if (rawWord == testWord) {
		return 0;
	} else {
		return -1;
	}
}

/**
* @param buffer - pointer to input data buffer
* @param numElements - number of elements in the input buffer
*/
static void xorshift64_postProcess(uint8_t *buffer, int numElements) {
	xorshift64_postProcessWords((uint64_t *)buffer, numElements / 8);
}

/**
*
* @param buffer - pointer to input data buffer
* @param numElements - number of elements in the input buffer
*/
static void xorshift64_postProcessWords(uint64_t *buffer, int numElements) {
	int i;
	for(i = 0; i < numElements; i++) {
		buffer[i] = xorshift64_postProcessWord(buffer[i]);
	}
}

/**
* Apply Xorshift64 (Marsaglia's PPRNG method) to the raw word
* @param rawWord - word to post process
*/
static uint64_t xorshift64_postProcessWord(uint64_t rawWord) {
	uint64_t trueWord = rawWord;

	trueWord ^= trueWord >> 12;
	trueWord ^= trueWord << 25;
	trueWord ^= trueWord >> 27;
	return trueWord * (uint64_t)2685821657736338717;
}

/**
 * A function for testing a block of random bytes using 'repetition count'
 * and 'adaptive proportion' tests
 */
static void test_samples(void) {
	uint8_t value;
	int i;

	for (i = 0; i < TRND_OUT_BUFFSIZE; i++) {
		value = buffRndIn[i];

		//
		// Run 'repetition count' test
		//
		if (!rct.isInitialized) {
			rct.isInitialized = true;
			rct.lastSample = value;
		} else {
			if (rct.lastSample == value) {
				rct.curRepetitions++;
				if (rct.curRepetitions >= rct.maxRepetitions) {
					rct.curRepetitions = 1;
					if (++rct.failureCount > numFailuresThreshold) {
						if (rct.statusByte == 0) {
							rct.statusByte = rct.signature;
						}
					}
					#ifdef inDebugMode
					if (rct.failureCount >= 1) {
						printk(KERN_INFO "rct.failureCount: %d value: %d\n", rct.failureCount, value);
					}
					#endif
				}

			} else {
				rct.lastSample = value;
				rct.curRepetitions = 1;
			}
		}

		//
		// Run 'adaptive proportion' test
		//
		if (!apt.isInitialized) {
			apt.isInitialized = true;
			apt.firstSample = value;
			apt.curRepetitions = 0;
			apt.curSamples = 0;
		} else {
			if (++apt.curSamples >= apt.windowSize) {
				apt.isInitialized = false;
				if (apt.curRepetitions > apt.cutoffValue) {
					// Check to see if we have reached the failure threshold
					if (++apt.cycleFailures > numFailuresThreshold) {
						if (apt.statusByte == 0) {
							apt.statusByte = apt.signature;
						}
					}
					#ifdef inDebugMode
					if (apt.cycleFailures >= 1) {
						printk(KERN_INFO "apt.cycleFailures: %d value: %d\n", apt.cycleFailures, value);
					}
					#endif

				}
			} else {
				if (apt.firstSample == value) {
					++apt.curRepetitions;
				}
			}
		}
	}
}

/**
 * A function to initialize the repetition count test
 *
 */
static void rct_initialize(void) {
	memset(&rct, 0x00, sizeof (rct));
	rct.statusByte = 0;
	rct.signature = 1;
	rct.maxRepetitions = 5;
	rct_restart();
}

/**
 * A function to restart the repetition count test
 *
 */
static void rct_restart(void) {
	rct.isInitialized = false;
	rct.curRepetitions = 1;
	rct.failureCount = 0;
}

/**
 * A function to initialize the adaptive proportion test
 *
 */
static void apt_initialize(void) {
	memset(&apt, 0x00, sizeof (apt));
	apt.statusByte = 0;
	apt.signature = 2;
	apt.windowSize = 64;
	apt.cutoffValue = 5;
	apt_restart();
}

/**
 * A function to restart the adaptive proportion test
 *
 */
static void apt_restart(void) {
	apt.isInitialized = false;
	apt.cycleFailures = 0;
}

module_init( init_swrandom);
module_exit( exit_swrandom);
